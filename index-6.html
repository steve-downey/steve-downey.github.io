<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Stuff, and more stuff">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>What Comes to Mind (old posts, page 6) | What Comes to Mind</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.1/css/all.min.css" crossorigin="anonymous">
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="rss.xml">
<link rel="alternate" type="application/atom+xml" title="Atom" hreflang="en" href="feed.atom">
<link rel="canonical" href="https://sdowney.org/index-6.html">
<link rel="prev" href="index-7.html" type="text/html">
<link rel="next" href="index-5.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href=".">

            <span id="blog-title">What Comes to Mind</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav"></ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="archive.html" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="categories/index.html" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="mailto:sdowney@sdowney.dev" class="nav-link"><i class="fa fa-envelope"></i></a>
                </li>
<li class="nav-item">
<a href="https://github.com/steve-downey" class="nav-link">GitHub <i class="fa-brands fa-square-github"></i></a>
                </li>
<li class="nav-item">
<a href="https://mastodon.social/@Sdowney" class="nav-link">Mastodon <i class="fa-brands fa-mastodon"></i></a>
                </li>
<li class="nav-item">
<a href="https://bsky.app/profile/sdowney.bsky.social" class="nav-link">Bluesky <i class="fa-brands fa-square-bluesky"></i></a>
                </li>
<li class="nav-item">
<a href="feed.atom" class="nav-link">ATOM <i class="fa-solid fa-atom"></i></a>
                </li>
<li class="nav-item">
<a href="rss.xml" class="nav-link">RSS <i class="fa-solid fa-rss"></i></a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
    
        

    
        
    <div class="postindex">
            <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2008/02/01/email-check/" class="u-url">email check</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2008/02/01/email-check/" rel="bookmark">
            <time class="published dt-published" datetime="2008-02-01T03:19:00-05:00" itemprop="datePublished" title="2008-02-01 03:19">2008-02-01 03:19</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2007/12/18/camping-this-last-weekend-at-west-hills/" class="u-url">Camping this last weekend at West Hills</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2007/12/18/camping-this-last-weekend-at-west-hills/" rel="bookmark">
            <time class="published dt-published" datetime="2007-12-18T04:05:00-05:00" itemprop="datePublished" title="2007-12-18 04:05">2007-12-18 04:05</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <a href="http://www.sdowney.org/uploaded_images/shelter-744028.jpg"><img src="http://www.sdowney.org/uploaded_images/shelter-744009.jpg" alt="" border="0"></a>This is the shelter we stayed in. The high pitched roof helps keep the heat in, and the rain out. And the snow, although that mostly melted.<br><br><br><a href="http://www.sdowney.org/uploaded_images/garbagecan_turkey-709741.jpg"><img src="http://www.sdowney.org/uploaded_images/garbagecan_turkey-709735.jpg" alt="" border="0"></a><br>This was the point of the whole trip. A garbage can cooked turkey to share with friends and family. The can acts as an oven, with the charcoal providing way more than enough heat to cook the bird, which is impaled on a stake, holding it vertically in the middle of the can. The 15 pound bird cooked in just a few hours.<br><br><br><a href="http://www.sdowney.org/uploaded_images/jon_me_1-703021.jpg"><img src="http://www.sdowney.org/uploaded_images/jon_me_1-702999.jpg" alt="" border="0"></a><br>My boy Jonathan (on the left), me on the right, and our friend Joel in between. Yes, that's coffee in the mug. And, yes, it's a stainless steel vacuum mug. With a spill proof top. But not the one I leave at the office.<br><br><a href="http://www.sdowney.org/uploaded_images/mike_by_fire-741419.jpg"><img src="http://www.sdowney.org/uploaded_images/mike_by_fire-741415.jpg" alt="" border="0"></a><br>My other boy, Michael, against the far wall, near the fire. They're warming up after we sent them outside to do some of the cooking. Which was mostly making sure there were enough coals around the trash can.<br>We also made mashed potatoes, sweet potatoes, gravy, peas, corn bread, stuffing, and cherry and apple pies, cooked in dutch ovens. The dutch ovens were in the fireplace opposite the one in this picture, in the far corner of the shelter. Between the two fireplaces, the inside temperature got up into the 80s at one point. We had to open the doors to let out the heat.<br>And the smoke.<br><br>Everyone had a good time, and we came back with the same number of boys we left with.
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2007/11/26/office-1-me-0/" class="u-url">Office 1 (me 0)</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2007/11/26/office-1-me-0/" rel="bookmark">
            <time class="published dt-published" datetime="2007-11-26T16:52:00-05:00" itemprop="datePublished" title="2007-11-26 16:52">2007-11-26 16:52</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>"my office looks like a bookstore exploded in it, and then an electronics store was dropped on it to smother the flames." - J.Scalzi<br>http://scalzi.com/whatever/?p=152<br><br>The books are all triple stacked, and there are several more shelves surrounding the room....<br></p>
<p><a href="http://www.sdowney.org/uploaded_images/Photo_11-719126-719167.jpg"><img src="http://www.sdowney.org/uploaded_images/Photo_11-719126-719162.jpg" alt="" border="0"></a></p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2007/04/19/i-win/" class="u-url">I win</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2007/04/19/i-win/" rel="bookmark">
            <time class="published dt-published" datetime="2007-04-19T07:01:00-04:00" itemprop="datePublished" title="2007-04-19 07:01">2007-04-19 07:01</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p><a href="http://www.sdowney.org/uploaded_images/Photo_04-755754-756824.jpg"><img src="http://www.sdowney.org/uploaded_images/Photo_04-755754-756457.jpg" width="320"></a></p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2007/04/18/this-showed-up-in-my-local-bookstore/" class="u-url">This showed up in my local bookstore</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2007/04/18/this-showed-up-in-my-local-bookstore/" rel="bookmark">
            <time class="published dt-published" datetime="2007-04-18T01:21:00-04:00" itemprop="datePublished" title="2007-04-18 01:21">2007-04-18 01:21</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p><a href="http://www.sdowney.org/uploaded_images/Photo_04-784645-786361.jpg"><img src="http://www.sdowney.org/uploaded_images/Photo_04-784645-786081.jpg" width="320"></a></p>So I bought it. And there was at least one more face out copy, besides the one you see here.<p></p>
<p><br>And this is where I bought it:</p>
<p><br><a href="http://www.sdowney.org/uploaded_images/Photo_04-709444-710663.jpg"><img src="http://www.sdowney.org/uploaded_images/Photo_04-709444-710333.jpg" width="320"></a></p>
<br>Penn Books on the LIRR Level of Penn Station. Small store, but many shelves of SF, particularly if you know to look under the display table across from  the main set of shelves. The staff are outstanding. I got the first recommendation for Vinge's Rainbows (sic) End there. They also have an excellent classics and literature section. As in, when I mentioned that 'March Up Country' was (sort of) based on 'The Anabasis', they knew where it should be shelved, wondered why it wasn't there, and offered to order it. Which might just be good salesmanship, except, after picking up my copy, I was looking in the same section for a copy of the Eddas, which they had, and spotted another copy of the Anabasis.<br><br>Buy books there, if you can.
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2007/02/19/36/" class="u-url">36</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2007/02/19/36/" rel="bookmark">
            <time class="published dt-published" datetime="2007-02-19T03:22:00-05:00" itemprop="datePublished" title="2007-02-19 03:22">2007-02-19 03:22</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <h2>Using the Standard C++ Library in a Functional style.</h2> <p>The standard C++ library offers a number of  algorithms that have nearly exact analogues in functional languages, and are used in almost the same way. In particular std::accumulate and std::transform are powerful, and very general, algorithms. In functional programming literature, accumulate is usually referred to as fold, or foldl, and transform is known as map, or zipWith, depending on whether transform is the unary or binary function form.  </p> <p>To quickly review, accumulate takes an iterator range, and either sums the range, or applies a functor to each value together with the result of the last application of the functor. This can be thought of as putting the operation between each pair of elements in the range. When the operation is plus or times, the result is the sum or product of all of the elements in the list. This is useful, but not really exciting to most programmers. However, when you consider carefully what can be used as the functor argument, you realize that fold is a an extremely powerful algorithm.</p> <p>A quick example:</p> <p>std::list<int>&amp; cons(std::list<int>&amp; xs,int x)</int></int></p> <p>{</p> <p>    xs.push_back(x);</p> <p>    return xs;</p> <p>}</p> <p><br></p>
<p>int init[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};</p> <p>vector<int> v(init, init + 10);</int></p> <p><br></p> <p>std::list<int> empty;</int></p> <p>std::list<int> v2 = std::accumulate(v.begin(), v.end(), empty, cons);</int></p> <p><br></p> <p><br></p> <p>&gt; foldr (:) [] [1..10]</p>   <p>(Note, the lines of code starting with &gt; are Haskell equivalents to the C++ code, and SHOULD work at a ghci Prelude&gt; prompt. Since that's where I'm cutting and pasting from. Although it's sort of like literate haskell, the whole article probably won't compile since early definitions may conflict with later ones.)</p> <p>Cons is a list constructor function. It pushes its argument onto the end of the linked list, and then returns a reference to the list that the element was appended to. The fact that this function takes and returns a reference to a list is a compromise I've made between the C++ library and functional purity. Really, I should be taking and returning lists by value. Except that the overhead is unconscionable, turning an O(n) operation into an O(n^2) operation. Since there is no way of accessing the intermediate state, in this case, I'm safe, but you need to be careful in this analysis. Using cons() in your own code will modify the value, and you lose the referential transparency we're trying to maintain.  </p> <p>So the application of cons() using accumulate against an empty list copies the list into a new list. If we had supplied a non-empty list, we would have appended the lists together. Interesting, for an algorithm that's usually considered a purely numerical one.   </p> <p>Functional languages usually work with singly linked lists. A singly linked list has an append at the head only, and therefore the tail remains unchanged, and any references to the tail can not tell that there is a new list that uses it. In fact, a list might be the tail of several other lists, and there is no way of telling the difference. It would be possible to create a version of list that is singly linked, where cons returned by value, and in that case, two lists could share a tail, but have distinct heads. So long as the list held only immutable values (and properly, all values are immutable), you would be completely safe. <br><br></p> <p>Transform, or map, as it's know in FP circles, is another fundamental algorithm. Transform takes an iterator range and applies a functor to each element in the range and copies the result into a destination output iterator, or, in its second form, takes two ranges and a binary operator, and outputs the result of pair -wise evaluation of the elements in each range, through the output iterator.</p> <p><br></p>
<p>int func(int x)</p> <p>{</p> <p>    return x*x + x + 1;</p> <p>}</p> <p>// ...</p> <p>std::transform(v.begin(), v.end(), v2.begin(), func);</p> <p><br></p> <p>&gt; let func x = x*x + x + 1</p> <p>&gt; map func [1 .. 10]</p> <h2>Functions and function objects as first-class entities</h2> <p>As you can see, the core STL algorithms are fairly weak by themselves. That is, they don't really do anything by themselves. What they do is capture conventional patterns of function applications to collections. The real power is in the functions themselves. However, C++ functions are fairly limited. Let's say you wanted to write a function that added a constant K to its argument. One way is to write int adder(int x, int  K); Unfortunately, it's rather difficult to apply this function with the same constant to every element in a collection.</p> <p>{Actually, in a few moments we'll see how we can do exactly that almost trivially, but let's hold on to that thought.}</p> <p>Function objects, aka functors in the OO community (the name means something _entirely_ different in functional programming) , give us a way of extending what functions can do by letting us associate some additional information with the function call. We do this by creating an object with an operator()() method. That lets the object be used where a function is called for, and also to supply the additional information as part of the object the operator is part of.  </p> <p><br></p>
<p>class adder</p> <p>{</p> <p>    int K;</p> <p>public:</p> <p>    adder(int k) : K(k) <br></p>
<p>    {}</p> <p>     </p> <p>    int operator()(int i) const</p> <p>            {return K+i;}</p> <p>};</p> <p>Then we can do something like:</p> <p>std::transform(v.begin(), v.end(), v3.begin(), adder(5));</p> <p><br></p> <p>&gt; let adder x = (x +)</p> <p>&gt; let adder5 = adder 5</p> <p>&gt; map adder5 [1 .. 10]</p> <p>But, as you can see, that's a lot of work for a small function that we're probably only going to use in one place.  </p> <p>Still, it's nice to see that we now have an entity that can be used just like a function, but is also a first class entity in the C++ language.  </p> <h2>Lambda abstraction and Partial Application</h2> <p>So, how can the adder example be made more convenient. Something that you might actually use?<br>How about</p> <p>std::transform(v.begin(), v.end(), v4.begin(), _1 + 5);</p> <p><br></p> <p>&gt; map (x -&gt; x + 5) [1 .. 10]</p> <p>&gt; -- or, even cooler</p> <p>&gt; map ( + 5) [1 .. 10]  </p> <p>This is using the Boost Lambda library to constructed a function object in place. One that takes a single parameter, and returns that plus 5. That _1 is what as known as a placeholder. Its type is boost::lambda::placeholder1_type. (And, yes, the leading underscore followed by a number is a perfectly legal variable name.) The functor acts in this context as though it has an operator() with a signature like int operator()(int arg1), and when transform applies it, the output is the same as our earlier example using adder. Except we didn't have create a class just for this single use.</p> <p>The reason I say that it acts as though it has that signature in this context, is that the actual signature is much more complicated, involving quite a bit of template metaprogramming in order to deduce the correct signature given the actual types of the arguments. If, v, for example, was a vector of doubles, the lambda expression would need to calculate that the return type is also a double, since the type of (double + int) is double. And for non-builtin types, it can be much more complicated, particularly if the lambda expression has more than one free variable.</p> <p>For example:<br></p>
<p><br></p>
<p>k = (_1 * _2)(i,j);</p> <p><br></p> <p>&gt; let k = x y -&gt; x * y</p> <p>That lambda expression can be applied to any pair of arguments that has an operator*() defined for it, and then as long as k has an assignment operator that can accept the result of that operator*(), everything will just work. However, that flexibility comes with a cost. The actual type of (_1 *_2) is insanely complicated. With the version of boost that I have, with gcc 4.0.2, the type is:</p> <p>const boost::lambda::lambda_functor<boost::lambda::lambda_functor_base>, boost::tuples::tuple<boost::lambda::lambda_functor> &gt;, boost::lambda::lambda_functor<boost::lambda::placeholder> &gt;, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type&gt; &gt; &gt;</boost::lambda::placeholder></boost::lambda::lambda_functor></boost::lambda::lambda_functor_base></p> <p>Not a variable or member you would like to declare. Fortunately, it works together with boost::function. You can assign that functor to a boost::function for later use. e.g.</p> <p><br>boost::function<int> a = (_1 * _2);</int></p> <p>boost::function<double> b = (_1 * _2);</double></p> <p>This is also one of the powerful aspects of ML and Haskell, and most modern functional languages. They are strictly typed, but the types can be inferred by the compiler. So the programmer is, for the most part, freed from having to annotate the types of everything. But the compiler will still give you an error if you say something that is really impossible. You get most of the benefits of duck-typing, without having to worry that there is some case that you haven't covered in tests that will result in 'Does Not Understand'.</p> <p>The  boost::lambda library even supports currying, although with a syntax that is a little hard to work with:</p> <p>    boost::function<int> c = bind(protect(_1 * _2), i, _1);</int></p> <p>The protect call protects the evaluation of the lambda expression from the bind operation. The bind operation attaches an argument to an expression to be used when the expression is evaluated later. In this case, one of the arguments is a lambda placeholder, so that the result is equivalent to the lambda expression (i * _1).</p> <p>The documentation for boost::lambda is quite good, and is worth extensive study.  So I won't repeat it. Instead, let's focus on ways of using it that you might not have thought of otherwise.</p> <h2>Pipes and Filters Architecture</h2> <p>Pipes and Filters is one of the fundamental architectural patterns identified by Mary Shaw. On a Unix command line, this is expressed with | (pipe), &lt; (redirect stdin), &gt; (redirect stdout), and tools like tee and xargs. In a functional programing system, piping the output of one  function to the input of another is via function composition, that is with functions f and g, you compute f(g(x)). This is also sometimes written as f . g. read as f compose g.  </p> <p>Doing this can also be very useful in complex template programs, where the intermediate type is not known, or difficult to express, but when passed directly to another templated function, the compiler computes the type for us.</p> <p>The goal here is to take a sequence of functions, compose the entire sequence, and then apply that composed function to a sequence of values. Where we end up is</p> <p>    std::transform(</p> <p>            v.begin(),</p> <p>        v.end(),</p> <p>        std::ostream_iterator<int>(</int></p> <p>                    std::cout,</p> <p>                "t"),</p> <p>        foldl1(</p> <p>            fns.begin(),</p> <p>            fns.end(),</p> <p>            composer())</p> <p>        </p>
<div>); </div>
<p> </p> <p>The interesting part is the final stanza. What are foldl1 and composer?  Lets work our way outward. The composer is a functor that takes two boost::functions and returns a boost::function that composes them. It assumes that each of the functions has the same signature, which in this case is reasonable, since they've come out of a single sequence.  It binds together the two functions and a lambda placeholder, then converts that to a new boost::function.  </p> <p>class composer</p> <p>{</p> <p>public:</p> <p>    template<typename sig></typename></p> <p>    boost::function<sig></sig></p> <p>    operator()(boost::function<sig> f,</sig></p> <p>                          boost::function<sig> g)</sig></p> <p>            {</p> <p>        using boost::lambda::_1;</p> <p>        return bind(f, bind(g, _1));</p> <p>        }</p> <p>};</p> <p><br></p> <p>Constructing a version of composer that takes functions with different signatures and generates the correct return type is a little more complicated. Take a look at the example code. The trick is to use a nested struct that does the type computation based on the template arguments of the member function. A conventional template metaprogramming approach, but quite strange the first time you come across it.</p> <p>The next part is the function foldl1. The unusual name is borrowed from Haskell. Once you've learned C++, Java, and Ruby, Haskell is the next language you should learn. Foldl1 is an abbreviation for fold left with one argument. It's very similar to std::accumulate, with one key difference. Instead of starting with a base value, the first value in the sequence is used. This means that it can not be applied to an empty list, but it does avoid having to come up with an identity value, such as 0 for addition, or 1 for multiplication. We could use the function identity(x){return x;}, but that's an extra function call we don't need, and an extra argument to constructing the composed function. And, not all sets have an identity.</p> <p><br></p>
<p>template <typename iter><p>                    typename BinOp&gt;</p> <p>typename Iter::value_type</p> <p>foldl1(Iter first,</p> <p>              Iter last,</p> <p>              BinOp oper)</p> <p>{</p> <p>        typename Iter::value_type n</p> <p>                = *first++;</p> <p>        return std::accumulate(first,</p> <p>                                                      last,</p> <p>                                                      n,</p> <p>                                                      oper);</p> <p>}</p> <p>So, assuming that fns is, say, a std::vector<boost::function> &gt;,  then it's just a matter of pushing the elements of the sequence v through the composed function, and streaming them out through the ostream_iterator.   </boost::function></p>
<br></typename></p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2007/02/07/what-is-currying-an-aha-moment/" class="u-url">What is currying? an aha! moment</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2007/02/07/what-is-currying-an-aha-moment/" rel="bookmark">
            <time class="published dt-published" datetime="2007-02-07T03:19:00-05:00" itemprop="datePublished" title="2007-02-07 03:19">2007-02-07 03:19</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>Since it really is an aha! moment, the best I can do is tell you what led me to it, and hope that helps.<br><br>There is a difference between partial application and currying that most experts ignore, because they already understand, but they lie in wait ready to tell you that you have it all wrong.<br><br>And you won't understand because the concepts are &gt;thatI'll start with Haskell syntax for the type of a function that takes two integers and returns one.</p>
<p>Integer -&gt; Integer -&gt; Integer</p>
<p>in C that would be<br></p>
<p> int (*T)(int , int )<br><br></p>
<p>Now. what about a function that takes an int and returns a function<br>that takes an int and returns an int?</p>
<p>(using cdecl syntax)<br>declare T as  function (int) returning pointer to function (int) returning int<br></p>
<p>int (*T(int ))(int )<br></p>
<p>or, in Haskell<br>Integer -&gt; Integer -&gt; Integer</p>
<p>Wait.<br></p>
<p>Shouldn't those have different types in Haskell?  They look really much more different in C !<br></p>
<p>I can't tell the difference in Haskell between a function that takes two ints and returns an int, and a function that takes one int and returns a function that takes one int and returns an int.</p>
<p>Yes.</p>
<p>Exactly.</p>
<p>AHA!</p>
<p>a -&gt; b -&gt; c<br><br>a function that takes an a and returns a function that maps b to c, or a function that takes an a and a b and returns a c. They are entirely equivalent.</p>
<br><p><br></p>
<p><br></p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2007/02/02/functional-programming-in-c-part-1/" class="u-url">Functional Programming in C++ Part 1</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2007/02/02/functional-programming-in-c-part-1/" rel="bookmark">
            <time class="published dt-published" datetime="2007-02-02T05:17:00-05:00" itemprop="datePublished" title="2007-02-02 05:17">2007-02-02 05:17</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <h2>Introduction</h2>
<br><p><span>C++ is known to be a multi-paradigmed language. This is often construed<br>to mean you can program in both a procedural and and object oriented<br>style.  This is too limiting a view. C++, particularly with modern<br>library support, is more than capable of supporting programming in<br>the functional style. Even without modern libraries like boost, or<br>std::tr1, the Standard Template Library embodies many functional<br>concepts.</span></p>
<br><p><span>It also turns out  that the template system in C++ defines a<br>metaprogramming language that is a pure, non-strict, lazy, functional<br>language. Of course, since this was not by design, it is not a<br>particularly elegant language, as anyone who has had to do template<br>metaprogramming can attest. For right now, though, I'm going to stay<br>away from metaprogramming, and look just at what can be done in the<br>language with the facilities provided. </span><br></p>
<br><h2>What is functional programming</h2>
<br><p><span>At the base, it is performing computations by the pure application of<br>functions, with no side-effects. Of course C has allowed this since<br>its inception, and it is never considered a functional language.<br>There is a lot of debate, and at least a little acrimony, in<br>determining if a language is functional. There are certainly many<br>claims of 'my language is more functional that yours.' </span><br></p>
<br><p><span>Languages that are widely regarded as pure functional languages are Haskell and<br>ML. Haskell is also getting a lot of alpha geek buzz, for a number of<br>reasons, and has finally hit the stage where people are learning it<br>in order to work on something other than a Haskell compiler. </span><br></p>
<br><p><span>The flavor of ML most commonly encountered is O'caml. The optimizing<br>compilers for the language are quite powerful, and programs often<br>compete, and beat, equivalent C programs in efficiency and<br>performance. </span><br></p>
<br><p><span>The LISP family has deep functional roots, with Scheme being the version<br>that focuses the most on functional purity, as well as simplicity and<br>ease of teaching. Common Lisp has a much broader range of libraries<br>and facilties defined for it and standardised for it. </span><br></p>
<br><p><br><span>JavaScript, Ruby and Python also all have a strong functional component to them. </span><br></p>
<br><p><span>Examining these languages leads to the observation that the real keys seem to<br>be</span><br></p>
<ol>
<li>
<span> Functions as first class objects </span><br>
</li>
<li><span> Referential transparency of expressions</span></li>
<li><span> Partial application, a.k.a currying.</span></li>
<li><span> Unnamed functions, a.k.a lambda expressions</span></li>
</ol>
<br><p><span>All of these features have been implemented in C++, in the language<br>itself, in the Standard Library, in TR1, in Boost, or in custom<br>libraries such as FC++. This article will examine these in more<br>depth, and show how they can be profitably incorporated into your<br>existing practice.</span></p>
<br><p><span>First let's examine what the four cornerstones of functional programming<br>really mean.</span></p>
<br><p><span>Functions as first class objects means that functions can be used in the same<br>way as all other entities in the language. In particular, that they<br>can be passed as values to functions, returned as values from<br>functions, and new ones can be created at runtime. In C, function<br>pointers can be passed and returned as values, but creating new<br>functions is not (portably) possible. In C++, however, we can create<br>objects that overload operator(), that satisfy all of the desired<br>properties. Function pointers can also be treated much more generally<br>with std::tr1::function objects. </span><br></p>
<br><p><span>Referential transparency of expressions means that an expression, or any of its<br>sub-expressions can be replaced by the value of that expression or<br>sub-expression without changing the behavior of the program as a<br>whole. A computation will always return the same result, and will<br>only depend on the value of its arguments. This implies that there<br>are no side-effects to evaluating an expression. No globals that can<br>be changed, producing non-local changes elsewhere. This property<br>gives the programmer, and the compiler and runtime, strong<br>capabilities to reason about the program, optimize it, and<br>demonstrate its correctness.</span></p>
<br><p><span>Partial application is one of the most unusual, and most powerful, features<br>of functional programming. This is also known as currying, after<br>Haskell Curry, a mathematician in the mid 20<sup>th</sup> Century who<br>did some of the fundamental work in combinatory logic and the lambda<br>calculus. Currying takes a function of N parameters and turns it into<br>a function of N-1 parameters by fixing the value of one of the<br>formers arguments. Or, another way of looking at it, is to say that a<br>function that takes N arguments is equivalent to a chain of N<br>functions, each taking 1 argument and returning a function that<br>consumes the next argument. Haskell Curry invented it as a way of<br>talking about multi-variate functions in a theory of functions of one<br>variable. Well, Shoenfinkel invented it first, but shoenfinkling<br>never really caught on.</span></p>
<br><p><span>Unnamed functions don't sound very useful. However, combined with<br>higher-order functions, that is functions that take and return<br>functions as parameters, they become very powerful, and quite useful.<br>If you've ever wanted to supply a simple function inline in a one of<br>the STL algorithms, but were frustrated with the syntax:</span></p>
<br><p></p>
<blockquote>
<p>    <span>compose2(</span></p>
<span>        plus<int>(),<br></int></span><span>        compose2(</span><span>multiplies<int>(),<br></int></span><div>
<span>            bind2nd(plus<int>(),</int></span><span>0.0),</span>
</div>            bind2nd(plus<int>(),<span>0.0)),</span><span><br>       bind2nd(plus<int>(),1))</int></span><br></int>
</blockquote>
<br>you've wanted a better way of writing lambda expressions. Lambda calculus is one of the fundamental theories of computation, and while I'm temptedto start a lengthy exposition, I think a few of quick examples will<span>give you the flavor.</span><br><p><span>(Haskell)<br></span></p>
<blockquote><p>\x -&gt; x*x + x + 1</p></blockquote>
<br><p><span>(Lisp)<br><blockquote>(lambda (k) (+(+(* k k) k) 1) )</blockquote></span></p>
<br><p><span>(Boost.Lambda (c++))</span></p>
<p><span></span></p>
<blockquote><p>  _1 * _1 + _1 + 1</p></blockquote>
<br><p>The key is that you can provide a definition of a function and then bind<br>it to a variable, rather than a fixed name. Ideally with nearly the<br>same syntax as you would use if you did name the function. Functional<br>languages are often defined in terms of lambda expressions and the<br>lambda calculus, with syntactic sugar sprinkled on top to make it<br>more palatable. I'm using syntactic sugar in the techincal sense of a<br>well defined transformation from one syntactic form to a more<br>primitive syntactic form. The thing to keep in mind is that too much<br>syntactic sugar causes truth decay.</p>
<br><p><br><br></p>
<br><h2>Objects vs Values</h2>
<br><p>“<span>Just like an int” has been a mainstay of C++ programming since the very<br>beginning. The phrase indicates that you can create a new type with<br>all of the capabilities of a built-in type. What many programmers<br>don't realize is that the behavior of ints is a polar opposite of the<br>behavior expected of objects. That is because ints are quintessential<br>value types. And whereas an object is an entity with state and<br>identity, values have neither. This 7 here is indistinguishable from<br>that 7 over there. And 7 never changes (unless you;re using an old<br>version of FORTRAN) into 8. You evaluate an expression such as 7+1,<br>and produce an 8, but the original 7 is unaffected. Objects are<br>different. This object is always distinct from that object, even if<br>they have the same state. You can change Bob, and everyone who has a<br>reference to Bob sees the change also. Unfortunately, the mechanism<br>by which you produce new value types in C++ is exactly the same as<br>how you produce new object types. You declare a new class.</span></p>
<br><p><span>What you permit and accept by default with that class determines whether<br>instances of the class behave like values or like objects. The key<br>pieces of machinery in the language are familiar to all C++<br>programmers: default construction, copy construction, copy assignment<br>and destruction. The compiler will provide ones that by default act<br>(mostly) like a value. Mostly, because of the shallow vs deep issue,<br>and the fact that pointers are values, even if what they point to<br>isn't. So what all the compiler instantiated methods do is treat each<br>member of the class as  a value, and then create, copy, assign or<br>destroy it, in the order they are declared. Unfortunately, for the<br>programmer concerned with efficiency, and almost all C++ programmers<br>are, these copies are, or can be very expensive.</span></p>
<br><p><span>Objects, on the other hand, typically either do not accept the default<br>implementations, or they avoid invoking them. Usually when you say<br>object2 = object1, you want them to continue to refer to the same<br>entity. In fact, assignment is fraught with danger, with potential<br>slicing when assigning a derived to a base. Programmers will either<br>use a Handle/Body or pimpl_ pattern to separate the implementation<br>side of the class from the reference side of it, or use a smart<br>pointer such as std::tr1::shared_ptr. In the evil past, some<br>programmers would attempt to use raw pointers, and manage the<br>allocated resources by hand. In practice, it turns out that no one is<br>smart enough to do so successfully in any program of interesting<br>size. Or at the very least, if the original programmer is that smart,<br>the next person to attempt to enhance the system, or fix a bug, is<br>not that smart.</span></p>
<br><p><span>Lazy functional programming languages, such as Haskell, avoid the price of<br>copying values by only evaluating an expression when it is needed.<br>This is guaranteed to be correct because of referential transparency.<br>Although it can lead to puzzling runtime behavior. I've coded some<br>benchmarks which seem to take practically no time, because it turns<br>out that the calculation is never fully evaluated. This takes not<br>paying for what you don't use to the n-th degree. This call-by-need<br>behavior is why they are characterized as lazy. </span><br></p>
<br><p><span>Getting this behavior in C++ is tricky, but far from unheard of. One<br>technique, used in numerical libraries such as Blitz++, and pioneered<br>by Todd Veldhuizen, is known as expression templates.</span></p>
<br><p><span>The problem expression templates were introduced to solve is the creation<br>of unneeded temporaries. Take for example the code</span></p>
<br><p><span> </span></p>
<blockquote>
<p>Array A,B,C,D;</p>
<br><p> //<br>... stuff<br></p>
<br><p> D = A * B + C</p>
<br><p></p>
</blockquote>
<p><span>Where each of A, B, C and D are two-d arrays, with the usual definitions<br>for multiplication and addition. The straightforward implementation<br>of operators *() and +() lead to the creation and destruction of<br>temporaries, with associated memory allocation and destruction. e.g.</span></p>
<br><p><br><br></p>
<br><p><span><span>Array operator *(const Array&amp; lhs, const Array&amp; rhs);</span></span></p>
<br><p><span>has to create and return a new array, which might be quite large, only to<br>have it used temporarily in Array operator +(const Array&amp;, const<br>Array&amp;) and then discarded. And even once the expression on the<br>right hand side of the assignment statement is evaluated, it has to<br>be passed into the copy assignment operator and very likely discarded<br>afterwards. (note that this is not an initialization, so that<br>permitted optimization does not apply).</span></p>
<br><p><span>Template expressions change the operators to return something else, an<br>expression that encapsulates the arguments, and evaluates them only<br>when necessary. </span><br></p>
<br><p><span><span> ArrayExpression operator +(const Array&amp;, const Array&amp;amp;);</span></span></p>
<br><p><span>Where ArrayExpression looks something like</span></p>
<br><p><span><span>class<br>ArrayExpression {</span></span></p>
<br><p><span><span>const Array&amp; lhs;</span></span></p>
<br><p><span><span>const Array&amp; rhs;</span></span></p>
<br><p><span><span>//....<br>more stuff</span></span></p>
<br><p><span><span>double operator(int,int); //compute the value at the point</span></span></p>
<br><p><span><span>}</span></span></p>
<br><p><span>Now, for lazy languages, like Haskell, this can be built into the language<br>itself, and in this case the concept is called a 'thunk'. Because by<br>the time you need to think about it, the thought has already been<br>thunk. Yes, it's a really awful joke. You have to remember, we work<br>in an industry where an extremely popular language is named after an<br>obscure, although influential, comedy troupe. Other industries do not<br>consider understanding why Norwegian Blue Parrots are funny a job<br>qualification. Nor do most of our managers, unless they came up<br>through the ranks themselves. </span><br></p>
<br><p><span>Referential transparency makes thunks extremely powerful because not only can<br>they be passed around instead of fully evaluated values, once they<br>are fully evaluated, the system can remember that value and use it<br>from then on. This is very much like common sub-expression<br>elimination, only it is a runtime feature, as well as a compile time<br>optimization.</span></p>
<br><h2></h2>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2007/01/24/monads-rest-and-c-template-metaprogramming/" class="u-url">Monads, REST and C++ Template Metaprogramming</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2007/01/24/monads-rest-and-c-template-metaprogramming/" rel="bookmark">
            <time class="published dt-published" datetime="2007-01-24T04:08:00-05:00" itemprop="datePublished" title="2007-01-24 04:08">2007-01-24 04:08</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>OK, with that title, I'm sure to please almost no one. If you want to know how to do REST-ful programming in Haskell, or tie REST to C++, move along, there's nothing to see here. The connection isn't at the implementation level. Which is the whole point.<br>So what do REST,  Monads and (successful)  Template Metaprogramming have in common?<br>Strict maintenance of levels of abstraction, and extremely narrow interfaces between those levels.<br>What does that get you?<br>Extremely (and possibly maximally) reusable abstractions (code).<br>What triggered the realization for me was a paper on Arrows by Hughes, which asked the question 'Why are Monads so reusable when the have such a small interface', although not in those exact words. It dawned on me that they are so reusable exactly because they have such a narrow, but still very well defined, interface. They can do that because Monads are all about abstracting out features. A particular Monad will delagate all the real work down to the type it is being run over. Its real job is constraining the ways the values of the types it is a Monad over can be combined.<br>The analogue I have in mind for C++ MP is the swap() method. In a C++ template, we can assume that we can call swap on two values, that we otherwise know nothing about, and that the two values will be exchanged in a way that does not throw any exceptions, and is the best way of exchanging two values of that type. The abstract notion of swapping two values is delegated to the concrete implementation of the type being templated over.<br>A REST-ful web application exposes PUT, GET, POST, and DELETE on resources named by a URI.  Nominally not much to have a really rich experience. OTOH, Google Map mashups  contradict that.<br>It's not the richness of the interface of the metalevel, it's the richness allowed at level below. The narrow, but well defined, interface, where that interface delegates to a lower level abstraction, is exactly what enables composeability.<br>Monads, being firmly grounded in Functors in Category Theory, take this to an extreme level of rigor. There are laws that must be satisfied for a thing to be called a Monad, and those laws ensure that other Monads can interoperate, and achieve the Principle of Least Surprise.<br>I'm not intending this to be Yet Another Monad Tutorial. So I won't go too deep here. But monad transformers show a degree of generic reusability that is awfully hard to achieve with C++ templates, even though C++ templates have similar expressive power (with a horribly clumsy syntax).<br>Monads are functions (functors) that take types to types, and so correspond to mpl metafunctions. But they preserve the underlying structure on the types they operate over. In particular, composition is preserved. So if I have an function of type a -&gt; M b, and a function b -&gt; c, I get a working a -&gt; M c for free, just by using fmap. In C++ it would be like<br>template<typename b> foo(A)<br>and<br>C bar(B)<br>getting you to<br>template<c> foo(A)  by saying template fmap<foo>(a,b), or even better just fmap(a,b) and letting the compiler figure out types.<br>(where foo is something like<br>template<typename> foo(A a);)<br>That looks so impossible in C++, that most C++ programmers have no intuition about it.<br>But every time you wish that you didn't have to write some type that the compiler already knows, like the iterator or value_type or return_value, particularly when they get really messy, you're looking for what Monads, or at least what Hindley-Milner type inference, provide.</typename></foo></c></typename></p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2007/01/20/rest-in-peace-robert-anton-wilson/" class="u-url">rest in peace robert anton wilson</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2007/01/20/rest-in-peace-robert-anton-wilson/" rel="bookmark">
            <time class="published dt-published" datetime="2007-01-20T05:29:00-05:00" itemprop="datePublished" title="2007-01-20 05:29">2007-01-20 05:29</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>oh<br>yes<br>of course<br>i had forgotten<br>my god, it's full of stars</p>
                </div>
            </article>
</div>
    
        <ul class="pager postindexpager clearfix">
<li class="previous"><a href="index-7.html" rel="prev">Newer posts</a></li>
            <li class="next"><a href="index-5.html" rel="next">Older posts</a></li>
        </ul>
<!--End of body content--><footer id="footer">
            Contents © 2024         <a href="mailto:sdowney@sdowney.dev">Steve Downey</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a> - 
 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
 <img alt="Creative Commons License BY-NC-SA" style="border-width:0; margin-bottom:12px;" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a>
            
            
        </footer>
</div>
</div>


        <script src="assets/js/all-nocdn.js"></script><script src="assets/js/luxon.min.js"></script><!-- fancy dates --><script>
        luxon.Settings.defaultLocale = "en";
        fancydates(2, {"preset": false, "format": "yyyy-MM-dd HH:mm"});
        </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-VGV27RDN3E"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VGV27RDN3E');
</script>
</body>
</html>
