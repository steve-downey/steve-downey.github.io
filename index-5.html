<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Stuff, and more stuff">
<meta name="viewport" content="width=device-width">
<title>What Comes to Mind (old posts, page 5) | What Comes to Mind</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer">
<link rel="stylesheet" href="assets/css/rst.min.css">
<link rel="stylesheet" href="assets/css/foundation.min.css">
<link rel="stylesheet" href="assets/css/app.css">
<link rel="stylesheet" href="assets/css/modus-vivendi-tinted.css">
<link href="assets/css/custom.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="alternate" type="application/atom+xml" title="Atom" href="feed.atom">
<link rel="canonical" href="https://sdowney.org/index-5.html">
<link rel="prev" href="index-6.html" type="text/html">
<link rel="next" href="index-4.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>

    

    
<div class="top-bar">
<div class="top-bar-left">
<ul class="menu">
<li class="menu-text"><a href="https://sdowney.org/" title="What Comes to Mind" rel="home">What Comes to Mind</a></li>
                <li><a href="archive.html">Archives</a></li>
                <li><a href="categories/index.html">Tags</a></li>
                <li><a href="mailto:sdowney@sdowney.dev"><i class="fa fa-envelope"></i></a></li>
                <li><a href="https://github.com/steve-downey">GitHub <i class="fa-brands fa-square-github"></i></a></li>
                <li><a href="https://mastodon.social/@Sdowney">Mastodon <i class="fa-brands fa-mastodon"></i></a></li>
                <li><a href="https://bsky.app/profile/sdowney.bsky.social">Bluesky <i class="fa-brands fa-square-bluesky"></i></a></li>
                <li><a href="feed.atom">ATOM <i class="fa-solid fa-atom"></i></a></li>
                <li><a href="rss.xml">RSS <i class="fa-solid fa-rss"></i></a></li>
    
    
    </ul>
</div>
</div>

    

<div class="callout large primary">
<div class="row column text-center">

<h1>What Comes to Mind</h1>
<h2 class="subheader">Stuff, and more stuff</h2>

</div>
</div>

<div class="row medium-8 large-7 columns">


    <div class="blog-post">
    <h3>
<a href="posts/index.php/2006/03/28/types-and-programming-languages-chapter-4/">Types and Programming Languages: Chapter 4</a><br><small>2006-03-28 04:31</small>
</h3>
    <div>

        <p>I'm working through Types and Programming Languages, by Benjamin Pierce.<br><br><br><br>I'm up to somewhere around chapter 13, References, but it's starting not to make sense. Which means it's time to back up and do more of the work, instead of just nodding as though I really understand it.<br><br>One of the things he does is build typecheckers for the languages he describes, in the language ocaml, or Objective Caml, a version of the language ML. For a variety of reasons, I'm trying to implement in Haskell. Mostly to give me something concrete to work on that isn't too large in scope to learn the language a little bit. aSomething more than 'Hello, World!', strip_spaces, or traverse a linked list, but less than a 'real application'.<br><br>For those not familiar, a typechecker is somewhere between a compiler and a grqammar driven parser. A type checker inspects what you give it for type correctness and consitency. It makes sure that you don't assign a Foo to a Bar, unless there's a rule in the typesystem that says you can. It may, in the process of typechecking, do some steps that a compiler also does, like reduce expressions, but it does this in the interest of determining what the type, not the value, is. Of course, if I were writing a compiler, it would make sense not to throw away that information, and do a bit of both at once.<br><br>That does lead me to a bit of a sub-rant. The first step in the process I'm working on is parsing the textual expression. Which means using a parsing library. (Pierce does, so it isn't cheating) Haskell has two; happy, a yacc analogue, and parsec, a 'monadic parser combinator' library. Since the point of doing this in Haskell is to get a better idea what phrases like 'monadic parser combinator' libraries mean, I was a bit biased towards Parsec. I already know and loathe yacc.<br><br>So I start in on the documentation. At least it has some. That's a nice benfit of the fact that Haskell grew up in the acadamic community. They need to publish or perish, and the publication serves as documentation. Somewhat, sort of. Although Parsec doesn't really suffer in that respect. The docs are pretty clear. They just suffer from the same problem that all parser lib docs do. They want to show that you can implement an entire compiler inside the parser.<br><br>And that's usually a bad idea.<br><br>The docs show you how you can attach interesting semantic actions to events in the parser, like evaluating the expression that's currently being parsed. However, in practice, that's hardly ever what you want to do. You want the parse to return something that abstracts the textual expression into a data structure, usually some kind of abstract syntax tree, where the nodes in the tree reflect elements in the grammar. Then you can write other stuff that accepts the AST and processes it in interesting ways, like compiling or typechecking it.<br><br>That's certainly what Pierce's code does in ML. And I'm trying to avoid being too inventive.<br><br>In any case, it turned out to be pretty trivial to return an AST from a Parsec parser, and in fact, all the examples of real parsers that come with Parsec take that approach. Which gave me some comfort about being on the right track.<br><br>Now, the arith language that we're starting with is pretty primitive. It has booleans and  non-negative integers, aka natural numbers . And the latter are all of the form  successor 0' or 'successor successor 0', meaning 1 and 2, respectively. Not a real language, but a place to start. Complicated enough that a few theorems could be proved non-trivially, but not so complicated you couldn't easily work everything by hand.<br><br>The language's syntax can be described with the following grammar<br></p>
<pre><br>t ::=<br>true<br>false<br>if t then t else t<br>0<br>succ t<br>pred t<br>isZero t<br></pre>
<br><br><br>This tranlates to the Haskell datatype ArithExpr:<br><pre><br>data ArithExpr<br>= TmTrue<br>| TmFalse<br>| TmIfExpr ArithExpr ArithExpr ArithExpr<br>| TmZero<br>| TmSucc ArithExpr<br>| TmPred ArithExpr<br>| TmIsZero ArithExpr<br>deriving (Show, Eq)<br></pre>
<br><br>Note that's almost a mechanical transliteration, and that's exactly what I'm aiming for. I'm a firm believer in the rule that there are two kinds of source code, that which obviously has no defects, and that which has no obvious defects.<br><br>So now we need a parser that will return those terms. In Parsec, that looks like this:<br><pre><br>arithExpr :: Parser ArithExpr<br>arithExpr =<br>    trueExpression<br> falseExpression<br> ifExpression<br> zeroExpression<br> succExpression<br> predExpression<br> isZeroExpression<br> parens arithExpr<br>"expression"<br></pre>
<br><br>So the arithExpr is a parser of ArithExpr, and the parser returns either a trueExpression, falseExpression, ifExpression, etc.<br><br>Those look like:<br><pre><br>trueExpression =<br>do{ reserved "true"<br>; return TmTrue<br>}<br><br>falseExpression =<br>do{ reserved "false"<br>; return TmFalse<br>}<br><br>ifExpression :: Parser ArithExpr<br>ifExpression =<br>do{ reserved "if"<br>; condition &lt;- arithExpr            <br>; reserved "then"         <br>; thenClause &lt;- arithExpr   <br>; reserved "else"     <br>; elseClause &lt;- arithExpr    <br>; return  (TmIfExpr condition thenClause elseClause)         <br>} <br></pre>
<br><br>Hopefully, even if the Haskell syntax is unusual and unfamiliar, the intent is pretty clear. true, false, if, then, else are parsed as reserved words, and true and false just return a TmTrue and TmFalse respectively. The ifExpression is a bit more interesting. It parses if, then it looks for an arithExpression, a then followed by another arithExpr, and finally an else followed by a third arithExpr, and returns the three of them wrapped up in a TmIfExpr.<br><br>So with those out of the way, we can look at how to evaluate the expression returned by the parser, testing them against a set of evaluation rules. For this small language, there are only a few, in two sets.<br><br>For Booleans we have<br>terms<br><pre><br>t ::=<br>true<br>false<br>if t then t else t<br></pre>
<br><br>values<br><pre><br>v ::=<br>true<br>false<br></pre>
<br>evaluation rules<br><pre><br>if true then t2 else t3  -&gt; t2<br><br>if false then t2 else t3 -&gt; t3<br><br>t1 -&gt; t1'<br>----------<br>if t1 then t2 else t3    -&gt; if t1' then t2 else t3<br></pre>
<br><br>Then arithmetic is added (the terms from above are elided)<br><br>Arithmetic Expressions<br><br>new terms<br><pre><br><br>t ::= ...<br> 0<br> succ t<br> pred t<br> iszero t<br></pre>
<br>new values<br><pre><br><br>v ::= ...<br> nv<br><br>nv ::=<br> 0<br> succ nv<br></pre>
<br><br>new evaluation rules<br><pre><br>t1 -&gt; t1'<br>---------<br>succ t1 -&gt; succ t1'<br><br>pred 0 -&gt; 0<br><br>pred (succ nv1) -&gt; nv1<br><br>t1 -&gt; t1'<br>--------<br>pred t1 -&gt; pred t1'<br><br>iszero 0 -&gt; true<br><br>iszero (succ nv1) -&gt; false<br><br>t1 -&gt; t1'<br>--------<br>iszero t1 -&gt; iszero t1'<br></pre>
<br><br><br>So now we want to transliterate those evaluation rules into a single step evaluator. Now, Pierce writes his in such a way that it throws an exception when no rule matches. I haven't figured out exceptions in Haskell, and in any case he does note in a footnote that they really aren't considered good style in ML in the way that he uses them, to terminate a recursive functions.<br><br>Instead, I'm choosing to represent the eval function as possibly returning a value, and in Haskell, that's returning a Maybe. So the signature of my eval1 is<br><pre><br>eval1 :: ArithExpr -&gt; Maybe ArithExpr<br></pre>
<br><br>and the evaluation rules can be written like so<br><pre><br>eval1 (TmIfExpr TmTrue  t _) = Just t<br><br>eval1 (TmIfExpr TmFalse _ t) = Just t<br><br>eval1 (TmIfExpr t1 t2 t3) =<br>let t1' = eval1 t1<br>in  case t1' of<br>      { Just t1'' -&gt; Just $ TmIfExpr t1'' t2 t3<br>      ; Nothing -&gt; Nothing<br>      }<br><br></pre>
<br><br>That is, if we're eval'ing an if expression, and the first clause is true or false, we can reduce it to either the then clause or the else clause immediately. On the other hand, if it doesn't match those, we can instead evaluate the first term, and return an if expression with the first term evaluated. If the first term doesn't evaluate, then we return nothing. I'm taking advantage of pattern matching in Haskell to select the right function based on the details of the argument supplied. They all take a single argument, but I'm asking to distinguish what constructor was used to create that argument. The '_' character means that I don't are what the type or value of that part of the argument is, match anything.<br><br>This is the way I wrote it at first, at least. I ran this by the haskell-cafe mailling list, and recieved some suggestions that I wasn't taking good advantage of Maybe being a monad, and that it might make more sense to do the sub-eval in a do block. In particular the advice in <a href="http://www.nomaware.com/monads/html/maybemonad.html">Nomaware's All About Monads tutorial</a> is exactly on point. Those Nothings and Justs don't need to be there.<br><br>I'll be reworking the code to adopt those suggestions before going much further.<br><br>To do the full evaluation, we run the eval1 until we can't anymore. That's<br><pre><br>eval t =<br>let t' = eval1 t<br>in case t' of<br>   { Just t'' -&gt; eval t''<br>   ; Nothing -&gt; t<br>   }<br><pre><br><br>Here's all the code so far:<br>ArithParser.hs<br><pre><br><span>module</span> ArithParser ( parseArith<br>                  , parseArithFromFile<br>                  , arithExpr            <br>                  , ParseError<br>                  ) <span>where</span><br><br><span>import</span> Char<br><span>import</span> Monad<br><span>import</span> Arith<br><br><span>-- Parsec<br></span><span>import</span> Text.ParserCombinators.Parsec<br><span>import</span> Text.ParserCombinators.Parsec.Expr<br><span>import</span> <span>qualified</span> Text.ParserCombinators.Parsec.Token <span>as</span> P<br><span>import</span> Text.ParserCombinators.Parsec.Language (haskellStyle)<br><br><br><span>parseArithFromFile</span> <span>::</span> String <span>-&gt;</span> IO (Either ParseError ArithExpr)<br><span>parseArithFromFile</span> fname <span>=</span><br>   parseFromFile arithExpr fname<br><br><span>parseArith</span> sourceName source <span>=</span><br>   parse arithExpr sourceName source<br><br><span>arithExpr</span> <span>::</span> Parser ArithExpr     <br><span>arithExpr</span> <span>=</span><br>       trueExpression<br> falseExpression<br>   &lt;|&gt; ifExpression<br>   &lt;|&gt; zeroExpression<br>   &lt;|&gt; succExpression<br>   &lt;|&gt; predExpression<br>   &lt;|&gt; isZeroExpression<br>   &lt;|&gt; parens arithExpr<br>   &gt; "<span>expression</span>"<br><br><br><span>trueExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>true</span>"<br>     ; return TmTrue<br>     }<br><br><span>falseExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>false</span>"<br>     ; return TmFalse<br>     }<br><br><span>zeroExpression</span> <span>::</span> Parser ArithExpr<br><span>zeroExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>0</span>"<br>     ; return TmZero<br>     }<br><br><span>ifExpression</span> <span>::</span> Parser ArithExpr<br><span>ifExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>if</span>"<br>     ; condition <span>&lt;-</span> arithExpr<br>     ; reserved "<span>then</span>"<br>     ; thenClause <span>&lt;-</span> arithExpr<br>     ; reserved "<span>else</span>"<br>     ; elseClause <span>&lt;-</span> arithExpr<br>     ; return  (TmIfExpr condition thenClause elseClause)<br>     }<br><br><span>succExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>succ</span>"<br>     ; expr <span>&lt;-</span> arithExpr<br>     ; return  (TmSucc expr)<br>     }<br><br><span>predExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>pred</span>"<br>     ; expr <span>&lt;-</span> arithExpr<br>     ; return (TmPred expr)<br>     }<br><br><br><span>isZeroExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>iszero</span>"<br>     ; expr <span>&lt;-</span> arithExpr<br>     ; return  (TmIsZero expr)<br>     }<br><br><br><br><span>-----------------------------------------------------------<br>-- Tokens<br>-- Use qualified import to have token parsers on toplevel<br>-----------------------------------------------------------<br></span><span>tokenParser</span>     <span>=</span> P.makeTokenParser haskellStyle  <br><br><span>parens</span>          <span>=</span> P.parens tokenParser   <br><span>braces</span>          <span>=</span> P.braces tokenParser   <br><span>semiSep1</span>        <span>=</span> P.semiSep1 tokenParser   <br><span>whiteSpace</span>      <span>=</span> P.whiteSpace tokenParser   <br><span>symbol</span>          <span>=</span> P.symbol tokenParser   <br><span>identifier</span>      <span>=</span> P.identifier tokenParser   <br><span>reserved</span>        <span>=</span> P.reserved tokenParser   <br><span>natural</span>         <span>=</span> P.natural tokenParser   <br><span>charLiteral</span>     <span>=</span> P.charLiteral tokenParser   <br><span>stringLiteral</span>   <span>=</span> P.stringLiteral tokenParser   <br></pre><br>Arith.hs<br><pre><br><span>module</span> <span>Arith</span> <span>where</span><br><br><br><br><span>data</span> <span>ArithExpr</span><br><span>=</span> <span>TmTrue</span><br><span>|</span> <span>TmFalse</span><br><span>|</span> <span>TmIfExpr</span> <span>ArithExpr</span> <span>ArithExpr</span> <span>ArithExpr</span><br><span>|</span> <span>TmZero</span><br><span>|</span> <span>TmSucc</span> <span>ArithExpr</span><br><span>|</span> <span>TmPred</span> <span>ArithExpr</span><br><span>|</span> <span>TmIsZero</span> <span>ArithExpr</span><br><span>deriving</span> (<span>Show</span>, <span>Eq</span>)<br><br><span>isNumericalVal</span> <span>::</span> <span>ArithExpr</span> <span>-&gt;</span> <span>Bool</span><br><span>isNumericalVal</span> <span>TmZero</span>     <span>=</span> <span>True</span><br><span>isNumericalVal</span> (<span>TmSucc</span> t) <span>=</span> isNumericalVal t<br><span>isNumericalVal</span> (<span>TmPred</span> t) <span>=</span> isNumericalVal t<br><span>isNumericalVal</span> <span>_</span>          <span>=</span> <span>False</span><br><br><br><br><span>isVal</span> <span>::</span> <span>ArithExpr</span> <span>-&gt;</span> <span>Bool</span><br><span>isVal</span> <span>TmTrue</span> <span>=</span> <span>True</span><br><span>isVal</span> <span>TmFalse</span> <span>=</span> <span>True</span><br><span>isVal</span> t<br><span>|</span> isNumericalVal t <span>=</span> <span>True</span><br><span>|</span> not (isNumericalVal t) <span>=</span> <span>False</span><br><span>isVal</span> <span>_</span> <span>=</span> <span>False</span><br><br><br><br><span>eval1</span> <span>::</span> <span>ArithExpr</span> <span>-&gt;</span> <span>Maybe</span> <span>ArithExpr</span><br><br><span>eval1</span> (<span>TmIfExpr</span> <span>TmTrue</span>  t <span>_</span>) <span>=</span> <span>Just</span> t<br><br><span>eval1</span> (<span>TmIfExpr</span> <span>TmFalse</span> <span>_</span> t) <span>=</span> <span>Just</span> t<br><br><span>eval1</span> (<span>TmIfExpr</span> t1 t2 t3) <span>=</span><br><span>let</span> t1' <span>=</span> eval1 t1<br><span>in</span>  <span>case</span> t1' <span>of</span><br>          { <span>Just</span> t1'' <span>-&gt;</span> <span>Just</span> <span>$</span> <span>TmIfExpr</span> t1'' t2 t3<br>          ; <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span> <span>--Just $ TmIfExpr t1 t2 t3<br></span>            }<br><br><span>eval1</span> (<span>TmSucc</span> t) <span>=</span><br><span>let</span> t' <span>=</span> eval1 t<br><span>in</span>  <span>case</span> t' <span>of</span><br>        { <span>Just</span> t'' <span>-&gt;</span> <span>Just</span> <span>$</span> <span>TmSucc</span> t''<br>        ; <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span> <span>--Just $ TmSucc t<br></span>          }<br><br><span>eval1</span> (<span>TmPred</span> <span>TmZero</span>) <span>=</span> <span>Just</span> <span>TmZero</span><br><br><span>eval1</span> (<span>TmPred</span> (<span>TmSucc</span> t))<br><span>|</span> isNumericalVal t <span>=</span> <span>Just</span> t<br><br><span>eval1</span> (<span>TmPred</span> t) <span>=</span><br><span>let</span> t' <span>=</span> eval1 t<br><span>in</span> <span>case</span> t' <span>of</span><br>       { <span>Just</span> t'' <span>-&gt;</span> <span>Just</span> <span>$</span> <span>TmPred</span> t''<br>       ; <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span> <span>-- Just $ TmPred t<br></span>         }<br><br><span>eval1</span> (<span>TmIsZero</span> <span>TmZero</span>) <span>=</span> <span>Just</span> <span>TmTrue</span><br><br><span>eval1</span> (<span>TmIsZero</span> (<span>TmSucc</span> t))<br><span>|</span> isNumericalVal t <span>=</span> <span>Just</span> <span>TmFalse</span><br><br><span>eval1</span> (<span>TmIsZero</span> t) <span>=</span><br><span>let</span> t' <span>=</span> eval1 t<br><span>in</span> <span>case</span> t' <span>of</span><br>       { <span>Just</span> t'' <span>-&gt;</span> <span>Just</span> <span>$</span> <span>TmIsZero</span> t''<br>       ; <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span> <span>-- Just $ TmIsZero t<br></span>         }<br><br><span>eval1</span> <span>_</span> <span>=</span> <span>Nothing</span><br><br><span>eval</span> t <span>=</span><br><span>let</span> t' <span>=</span> eval1 t<br><span>in</span> <span>case</span> t' <span>of</span><br>       { <span>Just</span> t'' <span>-&gt;</span> eval t'' <span>--if (t /= t'') then eval t'' else t<br></span>         ; <span>Nothing</span> <span>-&gt;</span> t<br>       }<br></pre><br><br><br></pre></pre>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2006/03/20/solaris-network-install-using-linux-dhcp-server/">Solaris network install using Linux DHCP server</a><br><small>2006-03-20 20:42</small>
</h3>
    <div>

        <p>This weekend's tech project was getting an old Sun Ultra 5 up and running with a new version of Solaris, in this case Solaris Nevada b33, so I can play with toys like opensolaris, dtrace, zfs,etc.<br><br>This particular machine doesn't have a cdrom, so in order to get things working I had to do a network install. Or I could have installed a cdrom, since it's an IDE based machine, but that wouldn't have been nearly as much fun.<br><br>I hosted the install on a Netra T1, so most of the installation instructions were just cut-and-paste from the Sun documentation. <a href="http://docs.sun.com/app/docs/doc/817-5504">Solaris 10 Installation Guide: Network-Based Installations</a><br><br>(Note: The T1 will eventually be providing network services, and live in the basement. It's a little loud sitting on my desk. That's why it's not going to be the Sparc play machine.)<br><br>The complicated part was the DHCP server. I already have one on my network, on a Debian Linux box, and didn't want to try having two of them. That would probably be bad.<br><br>In order to supply all of the information for the install, I needed to add a new name space to the dhcp.conf, a class and subclass for the particular hardware type, and some information specific to the machine.<br><br>Here's the relevant pieces from dhcpd.conf:<br>First the SUNW option namespace, used by the Sun net installation:<br></p>
<pre><br>option space                    SUNW;<br>option SUNW.SrootOpt            code 1 = text;<br>option SUNW.SrootIP4            code 2 = ip-address;<br>option SUNW.SrootNM             code 3 = text;<br>option SUNW.SrootPTH            code 4 = text;<br>option SUNW.SswapIP4            code 5 = ip-address;<br>option SUNW.SswapPTH            code 6 = text;<br>option SUNW.SbootFIL            code 7 = text;<br>option SUNW.Stz                 code 8 = text;<br>option SUNW.SbootRS             code 9 = integer 16;<br>option SUNW.SinstIP4            code 10 = ip-address;<br>option SUNW.SinstNM             code 11 = text;<br>option SUNW.SinstPTH            code 12 = text;<br>option SUNW.SsysidCF            code 13 = text;<br>option SUNW.SjumpsCF            code 14 = text;<br>option SUNW.Sterm               code 15 = text;<br>option SUNW.SbootURI            code 16 = text;<br>option SUNW.SHHTPProxy          code 17 = text;<br></pre>
<br><br>Then the class and subclass based on the vendor-class-identifier, which is sent out by the Ultra 5 when it's trying to DHCP an address. <br><pre><br>class "vendor-classes" {<br>  match option vendor-class-identifier;<br>}<br><br>subclass "vendor-classes"  "SUNW.Ultra-5_10" {<br>      vendor-option-space     SUNW;<br>      option SUNW.SbootURI    = "tftp://10.10.1.131/inetboot.SUN4U.Solaris_11-1 ";<br>      option SUNW.SinstIP4  10.10.1.131;<br>      option SUNW.SinstNM  = "heimdall";<br>      option SUNW.SinstPTH = "/export/solaris11/install";<br>      option SUNW.SrootIP4  10.10.1.131;<br>      option SUNW.SrootNM = "heimdall";<br>      option SUNW.SrootPTH = "/export/solaris11/install/Solaris_11/Tools/Boot" ;<br>}<br></pre>
<br>Then, the particular information for the machine I'm trying to boot and install from the net:<br><pre><br>host chimera {<br>hardware ethernet 08:00:20:a2:22:66;<br>option domain-name "sdowney.org";<br>option host-name "chimera";<br>next-server  10.10.1.131;<br>fixed-address 10.10.1.132;<br>}<br></pre>
<br>The machine I'm installing onto is chimera, which has the MAC address 08:00:20:a2:22:66. It will get the address 10.10.1.132. The install and boot server are both heimdall, which had IP addresses 10.10.1.131 respectively. The 'next-server' tells chimera to netboot from heimdall. I'm calling that out in particular because I wasted about an hour figuring out that I needed that. <br><br>Once all that was done, it was a 'simple' matter of running <span>boot net:dhcp - install</span> from the openboot OK prompt. <br><br>The machine isn't exactly a screamer by today's standards, it has a 333Mhz UltraSparc IIi chip in it, but it does have 512Mb of RAM, which covers a multitude of sins. I think I may start over with a larger HD, since the 7G drive that's in there now doesn't leave much room for experimentation.  I'll probably go ahead and put a DVDRW drive in there too, even though I don't need it now.
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2006/03/11/epsilon-delta-mathematics-and-computer-programming-number-sequence-puzzles-are-arbitrary/">Epsilon-Delta: Mathematics and Computer Programming » Number Sequence Puzzles are Arbitrary</a><br><small>2006-03-11 15:53</small>
</h3>
    <div>

        <a href="http://epsilondelta.wordpress.com/2006/03/09/number-sequence-puzzles-are-arbitrary/">Epsilon-Delta: Mathematics and Computer Programming » Number Sequence Puzzles are Arbitrary</a>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2006/02/21/brew-day/">Brew Day!</a><br><small>2006-02-21 01:13</small>
</h3>
    <div>

        <table border="1"><tbody>
<tr>
<td><b>Brewer:</b></td>  <td colspan="2">Steve Downey</td>  <td><b><br></b></td>  <td colspan="2">-</td>     </tr>
<tr>
<td><b>Beer:</b></td>  <td colspan="2">February Ale</td>  <td><b>Style:</b></td>  <td colspan="2">American Amber Ale</td>   </tr>
<tr>
<td><b>Type:</b></td>  <td colspan="2">All grain</td>  <td><b>Size:</b></td>  <td colspan="2">5.5 gallons</td>   </tr>
<tr>
<td><b>Color:</b></td>  <td colspan="2"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr>
<td>13 HCU (~9 SRM)</td>            <td width="8"><br></td>    <td><img src="http://hbd.org/cgi-bin/recipator/gifcolor/swatch.gif?color0=218,116,18" border="0" height="21" width="38"></td>          </tr></tbody></table></td>  <td><b>Bitterness:</b></td>  <td colspan="2">38 IBU</td>   </tr>
<tr>
<td><b>OG:</b></td>  <td colspan="2" width="50">1.052</td>  <td><b>FG: (Est)<br></b></td>  <td colspan="2" width="50">1.012</td>   </tr>
<tr>
<td><b>Alcohol:</b></td>  <td colspan="5">5.2% v/v (4.1% w/w) (Estimated)<br>
</td>      </tr>
<tr>
<td><b>Grain:</b></td>  <td colspan="5">2 lb. Weyermann Dark Wheat<br>10 lb. Weyermann Vienna<br>1 lb. Weyermann Cara Amber</td>        </tr>
<tr>
<td><b>Mash:</b></td>      <td colspan="5">60% efficiency</td>         </tr>
<tr>
<td rowspan="1"><b>Boil:</b></td>  <td>60 minutes</td>  <td>SG 1.044</td>  <td colspan="3">6.5 gallons</td>     </tr>
<tr>
<td><b>Hops:</b></td>  <td colspan="5">1 oz. Cascade (5.3% AA, 60 min.)<br>1 oz. Cascade (5.3% AA, 30 min.)<br>1 oz. Cascade (5.3% AA, 5 min.)</td>
</tr>
</tbody></table>
<span><i><br>Recipe formatting and calculations by <a href="http://hbd.org/recipator">The Beer Recipator</a>.</i></span><br><br>Mashed with a single decoction. Doughed in with three gallons of water to 135 degrees F. Let rest for 15 minutes, then pulled a third of the thick mash and boiled for 15 minutes. Added back, and added hot liquor to reach 158 degrees F, and let rest for about an hour (during a trip to Target with the kids...)<br><br>Sparged with another 4 gallons of liquor and collected 6.5 gallons of sweet wort. Estimated efficiency, 60%. Low. Should probably investigate.<br><br>Added the first hops in while collecting the runoff.<br><br>Boiled for 60 minutes, with two hop additions at 30 minutes and at 5.  Also added 1 tsp of irish moss at 15 minutes.<br><br>Collected 5.5 gallons of 1.052 wort, and pitched 20 grams of Safeale 33 yeast.<br><br>Total time, around 6 1/2 hours. Although I still have some clean up.
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2006/02/13/bill-de-hora-i-think-i-figured-out-the-list-comprehensions-thing/">Bill de hÓra: I think I figured out the list comprehensions thing...</a><br><small>2006-02-13 18:37</small>
</h3>
    <div>

        <a href="http://www.dehora.net/journal/2006/02/i_think_i_figured_out_the_list_comprehensions_thing_1.html">Bill de hÓra: I think I figured out the list comprehensions thing...</a><br><br>I've been trying to understand this stuff myself, and Bill de hÓra's post has prodded me to write this down so I won't forget it again.<br><br>List comprehensions are really just syntatic sugar. And too much syntatic sugar can cause truth decay.<br><br>List comprehensions are forms in functional and related languages that allow you to generate an entire list with a description of the list. So, for example, I can get a list of the first 10 squares by:<br><div><blockquote>[ x * x | x [1,4,9,16,25,36,49,64,81,100]<br><br>That gives me a list of the squares of x, where x is an element of the list of integers from 1 to 10.  I can also add some more qualifiers, like<br><br><blockquote>[ x * x | x 3] </blockquote>
<br>[16,25,36,49,64,81,100]<br><br><br><blockquote>[i * j | i 5]</blockquote>[5,8,10,9,12,15,8,12,16,20,5,10,15,20,25]<br><br>This is all pretty neat, but what does it really mean?<br><br>You 'normally'  think of drawing a variable from each of the generating lists, with the right most one varying most quickly, and skipping if the variables fail to meet the condition. This provides a natural analogue to the looping constructs in most programming languages.<br><blockquote>
<pre><span>for (int i = 1; i <br><span> for (int j = 1; j <br><span>      if ((i + j) &gt; 5) {</span><br><span>            list.push(i*j);</span><br><span>        }</span><br><span>    }</span><br><span>}</span><br></span></span></pre>
<br>
</blockquote>That close, natural, analogue can be a code smell in functional programming. It may be an indication that you're thinking of the problem in terms of loops, updating variables, etc.<br><br>The intent of list comprehension is to simulate loops and conditions, but it can be defined in terms of map and list concat. (As far as I can tell, this is due to <a href="http://homepages.inf.ed.ac.uk/wadler/">P. Wadler</a>, in <a href="http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/slpj-book-1987.pdf">Simon Peyton-Jones's The Implementation of Functional Programming Languages</a> )<br><br><pre><br>[t | x   map (\x -&gt; t) u<br>[t | p, q]    ==&gt;  concat [ [t | q] | p ]<br>[t | b ]      ==&gt;  if (b) then [t] else []<br></pre>
<br>Note that the two qualifications p and q are reversed when translated.<br><br>concat will take the results of the simplified comprehension and concatenate all of the resulting lists together, eliminating empty lists.<br><br>Lets take the first, simple, example:<br><blockquote> [ x * x | x that translates to:<br><blockquote> map (\x -&gt; x * x) [1..10]</blockquote>The next example<br><blockquote>[ x * x | x 3]</blockquote>takes a few more steps<br><br>  concat [ [x * x | x&gt; 3] | x <br>concat ( map (\x -&gt; [x * x | x&gt;3]) [1..10] )<br><br>concat (map (\x -&gt; (if (x&gt;3) then [x*x] else [])) [1..10])<br><br>In this case, the list comprehension is more concise. On the other hand, the expanded version is a bit more suggestive. Particularly if I'm willing for it <span>not </span>to be a lambda expression.<br><br><br><br>
</blockquote>
</blockquote></div>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2006/02/01/picture-of-me-at-end-of-day/">Picture of me at end of day</a><br><small>2006-02-01 00:31</small>
</h3>
    <div>

        <p><img width="320" src="http://www.sdowney.org/mobile_images/Photo_01-790705.jpg"></p>
<p><br>This is me at the end of the day, playing with Blogger's new mobile posting feature, and my new cell phone camera.</p>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2006/02/01/oktale-novemberfest/">OktAle / Novemberfest</a><br><small>2006-02-01 00:08</small>
</h3>
    <div>

        <a href="http://www.sdowney.org/2005/10/oktale-novemberfest.html">OktAle / Novemberfest</a><br><br>I finished up the keg this week. That was pretty fast, for me. I usually end up with a few stray bottles of a brew hanging on forever. But, since the keg is really all or nothing, I just finished it up. <br><br>The only down side is that I don't have another brewing at the moment. I'll have to get to work on that this weekend. Probably a basic Pale Ale, consisting of whatever they have on hand at my local homebrew store,  <a href="http://www.homebrewshop.com/">Karp's Homebrew Shop</a>.
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2006/01/30/waterfall-2006-international-conference-on-sequential-development/">Waterfall 2006 - International Conference on Sequential Development</a><br><small>2006-01-30 16:25</small>
</h3>
    <div>

        <a href="http://www.waterfall2006.com/">Waterfall 2006 - International Conference on Sequential Development</a><br><br>Just what we need. A solid return to the successful development practices of the early 80's. The Waterfall development model, with emphasis on design up front, deliberate handoff between phases, a separate QA team, and producing extensive documentation at all times, is ripe for a comeback.
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2006/01/26/template-metaprogramming-google-search/">template metaprogramming - Google Search</a><br><small>2006-01-26 05:22</small>
</h3>
    <div>

        <a href="http://www.google.com/search?q=template+metaprogramming">template metaprogramming - Google Search</a><br><br>goddamnit - there ought to be more people who know more about template metaprogramming than I do by now. <br><br>And Todd Veldhuizen was someone I cribbed notes from when I wrote that article. <br><br>The Boost MPL stuff is excellent. Why aren't there another dozen links talking about it?
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2006/01/24/google-mobile-personalized-home/">Google Mobile - Personalized Home</a><br><small>2006-01-24 01:08</small>
</h3>
    <div>

        <a href="http://mobile.google.com/personalized/promo.html">Google Mobile - Personalized Home</a><br><br>Way cool. More neat stuff on my mobile phone.
    </div>

    </div>


        <div class="column row">
            <ul class="pagination" role="navigation" aria-label="Pagination">
<li>
                    <a href="index-6.html" rel="prev">« <span class="show-for-sr">Newer posts</span></a>
                </li>
                <li>
                    <a href="index-4.html" rel="next">» <span class="show-for-sr">Older posts</span></a>
                </li>
            </ul>
</div>


    





<hr>
<footer id="footer"><p><small>Contents © 2025         <a href="mailto:sdowney@sdowney.dev">Steve Downey</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a> - 
 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
 <img alt="Creative Commons License BY-NC-SA" style="border-width:0; margin-bottom:12px;" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a></small></p>
            
        </footer>
</div>

    



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VGV27RDN3E"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VGV27RDN3E');
</script>
</body>
</html>
