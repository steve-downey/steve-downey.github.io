<html><body><p>I'm working through Types and Programming Languages, by Benjamin Pierce.<br><br><br><br>I'm up to somewhere around chapter 13, References, but it's starting not to make sense. Which means it's time to back up and do more of the work, instead of just nodding as though I really understand it.<br><br>One of the things he does is build typecheckers for the languages he describes, in the language ocaml, or Objective Caml, a version of the language ML. For a variety of reasons, I'm trying to implement in Haskell. Mostly to give me something concrete to work on that isn't too large in scope to learn the language a little bit. aSomething more than 'Hello, World!', strip_spaces, or traverse a linked list, but less than a 'real application'.<br><br>For those not familiar, a typechecker is somewhere between a compiler and a grqammar driven parser. A type checker inspects what you give it for type correctness and consitency. It makes sure that you don't assign a Foo to a Bar, unless there's a rule in the typesystem that says you can. It may, in the process of typechecking, do some steps that a compiler also does, like reduce expressions, but it does this in the interest of determining what the type, not the value, is. Of course, if I were writing a compiler, it would make sense not to throw away that information, and do a bit of both at once.<br><br>That does lead me to a bit of a sub-rant. The first step in the process I'm working on is parsing the textual expression. Which means using a parsing library. (Pierce does, so it isn't cheating) Haskell has two; happy, a yacc analogue, and parsec, a 'monadic parser combinator' library. Since the point of doing this in Haskell is to get a better idea what phrases like 'monadic parser combinator' libraries mean, I was a bit biased towards Parsec. I already know and loathe yacc.<br><br>So I start in on the documentation. At least it has some. That's a nice benfit of the fact that Haskell grew up in the acadamic community. They need to publish or perish, and the publication serves as documentation. Somewhat, sort of. Although Parsec doesn't really suffer in that respect. The docs are pretty clear. They just suffer from the same problem that all parser lib docs do. They want to show that you can implement an entire compiler inside the parser.<br><br>And that's usually a bad idea.<br><br>The docs show you how you can attach interesting semantic actions to events in the parser, like evaluating the expression that's currently being parsed. However, in practice, that's hardly ever what you want to do. You want the parse to return something that abstracts the textual expression into a data structure, usually some kind of abstract syntax tree, where the nodes in the tree reflect elements in the grammar. Then you can write other stuff that accepts the AST and processes it in interesting ways, like compiling or typechecking it.<br><br>That's certainly what Pierce's code does in ML. And I'm trying to avoid being too inventive.<br><br>In any case, it turned out to be pretty trivial to return an AST from a Parsec parser, and in fact, all the examples of real parsers that come with Parsec take that approach. Which gave me some comfort about being on the right track.<br><br>Now, the arith language that we're starting with is pretty primitive. It has booleans and  non-negative integers, aka natural numbers . And the latter are all of the form  successor 0' or 'successor successor 0', meaning 1 and 2, respectively. Not a real language, but a place to start. Complicated enough that a few theorems could be proved non-trivially, but not so complicated you couldn't easily work everything by hand.<br><br>The language's syntax can be described with the following grammar<br></p><pre><br>t ::=<br>true<br>false<br>if t then t else t<br>0<br>succ t<br>pred t<br>isZero t<br></pre>
<br><br><br>This tranlates to the Haskell datatype ArithExpr:<br><pre><br>data ArithExpr<br>= TmTrue<br>| TmFalse<br>| TmIfExpr ArithExpr ArithExpr ArithExpr<br>| TmZero<br>| TmSucc ArithExpr<br>| TmPred ArithExpr<br>| TmIsZero ArithExpr<br>deriving (Show, Eq)<br></pre>
<br><br>Note that's almost a mechanical transliteration, and that's exactly what I'm aiming for. I'm a firm believer in the rule that there are two kinds of source code, that which obviously has no defects, and that which has no obvious defects.<br><br>So now we need a parser that will return those terms. In Parsec, that looks like this:<br><pre><br>arithExpr :: Parser ArithExpr<br>arithExpr =<br>    trueExpression<br> falseExpression<br> ifExpression<br> zeroExpression<br> succExpression<br> predExpression<br> isZeroExpression<br> parens arithExpr<br>"expression"<br></pre>
<br><br>So the arithExpr is a parser of ArithExpr, and the parser returns either a trueExpression, falseExpression, ifExpression, etc.<br><br>Those look like:<br><pre><br>trueExpression =<br>do{ reserved "true"<br>; return TmTrue<br>}<br><br>falseExpression =<br>do{ reserved "false"<br>; return TmFalse<br>}<br><br>ifExpression :: Parser ArithExpr<br>ifExpression =<br>do{ reserved "if"<br>; condition &lt;- arithExpr            <br>; reserved "then"         <br>; thenClause &lt;- arithExpr   <br>; reserved "else"     <br>; elseClause &lt;- arithExpr    <br>; return  (TmIfExpr condition thenClause elseClause)         <br>} <br></pre>
<br><br>Hopefully, even if the Haskell syntax is unusual and unfamiliar, the intent is pretty clear. true, false, if, then, else are parsed as reserved words, and true and false just return a TmTrue and TmFalse respectively. The ifExpression is a bit more interesting. It parses if, then it looks for an arithExpression, a then followed by another arithExpr, and finally an else followed by a third arithExpr, and returns the three of them wrapped up in a TmIfExpr.<br><br>So with those out of the way, we can look at how to evaluate the expression returned by the parser, testing them against a set of evaluation rules. For this small language, there are only a few, in two sets.<br><br>For Booleans we have<br>terms<br><pre><br>t ::=<br>true<br>false<br>if t then t else t<br></pre>
<br><br>values<br><pre><br>v ::=<br>true<br>false<br></pre>
<br>evaluation rules<br><pre><br>if true then t2 else t3  -&gt; t2<br><br>if false then t2 else t3 -&gt; t3<br><br>t1 -&gt; t1'<br>----------<br>if t1 then t2 else t3    -&gt; if t1' then t2 else t3<br></pre>
<br><br>Then arithmetic is added (the terms from above are elided)<br><br>Arithmetic Expressions<br><br>new terms<br><pre><br><br>t ::= ...<br> 0<br> succ t<br> pred t<br> iszero t<br></pre>
<br>new values<br><pre><br><br>v ::= ...<br> nv<br><br>nv ::=<br> 0<br> succ nv<br></pre>
<br><br>new evaluation rules<br><pre><br>t1 -&gt; t1'<br>---------<br>succ t1 -&gt; succ t1'<br><br>pred 0 -&gt; 0<br><br>pred (succ nv1) -&gt; nv1<br><br>t1 -&gt; t1'<br>--------<br>pred t1 -&gt; pred t1'<br><br>iszero 0 -&gt; true<br><br>iszero (succ nv1) -&gt; false<br><br>t1 -&gt; t1'<br>--------<br>iszero t1 -&gt; iszero t1'<br></pre>
<br><br><br>So now we want to transliterate those evaluation rules into a single step evaluator. Now, Pierce writes his in such a way that it throws an exception when no rule matches. I haven't figured out exceptions in Haskell, and in any case he does note in a footnote that they really aren't considered good style in ML in the way that he uses them, to terminate a recursive functions.<br><br>Instead, I'm choosing to represent the eval function as possibly returning a value, and in Haskell, that's returning a Maybe. So the signature of my eval1 is<br><pre><br>eval1 :: ArithExpr -&gt; Maybe ArithExpr<br></pre>
<br><br>and the evaluation rules can be written like so<br><pre><br>eval1 (TmIfExpr TmTrue  t _) = Just t<br><br>eval1 (TmIfExpr TmFalse _ t) = Just t<br><br>eval1 (TmIfExpr t1 t2 t3) =<br>let t1' = eval1 t1<br>in  case t1' of<br>      { Just t1'' -&gt; Just $ TmIfExpr t1'' t2 t3<br>      ; Nothing -&gt; Nothing<br>      }<br><br></pre>
<br><br>That is, if we're eval'ing an if expression, and the first clause is true or false, we can reduce it to either the then clause or the else clause immediately. On the other hand, if it doesn't match those, we can instead evaluate the first term, and return an if expression with the first term evaluated. If the first term doesn't evaluate, then we return nothing. I'm taking advantage of pattern matching in Haskell to select the right function based on the details of the argument supplied. They all take a single argument, but I'm asking to distinguish what constructor was used to create that argument. The '_' character means that I don't are what the type or value of that part of the argument is, match anything.<br><br>This is the way I wrote it at first, at least. I ran this by the haskell-cafe mailling list, and recieved some suggestions that I wasn't taking good advantage of Maybe being a monad, and that it might make more sense to do the sub-eval in a do block. In particular the advice in <a href="http://www.nomaware.com/monads/html/maybemonad.html">Nomaware's All About Monads tutorial</a> is exactly on point. Those Nothings and Justs don't need to be there.<br><br>I'll be reworking the code to adopt those suggestions before going much further.<br><br>To do the full evaluation, we run the eval1 until we can't anymore. That's<br><pre><br>eval t =<br>let t' = eval1 t<br>in case t' of<br>   { Just t'' -&gt; eval t''<br>   ; Nothing -&gt; t<br>   }<br><pre><br><br>Here's all the code so far:<br>ArithParser.hs<br><pre><br><span>module</span> ArithParser ( parseArith<br>                  , parseArithFromFile<br>                  , arithExpr            <br>                  , ParseError<br>                  ) <span>where</span><br><br><span>import</span> Char<br><span>import</span> Monad<br><span>import</span> Arith<br><br><span>-- Parsec<br></span><span>import</span> Text.ParserCombinators.Parsec<br><span>import</span> Text.ParserCombinators.Parsec.Expr<br><span>import</span> <span>qualified</span> Text.ParserCombinators.Parsec.Token <span>as</span> P<br><span>import</span> Text.ParserCombinators.Parsec.Language (haskellStyle)<br><br><br><span>parseArithFromFile</span> <span>::</span> String <span>-&gt;</span> IO (Either ParseError ArithExpr)<br><span>parseArithFromFile</span> fname <span>=</span><br>   parseFromFile arithExpr fname<br><br><span>parseArith</span> sourceName source <span>=</span><br>   parse arithExpr sourceName source<br><br><span>arithExpr</span> <span>::</span> Parser ArithExpr     <br><span>arithExpr</span> <span>=</span><br>       trueExpression<br> falseExpression<br>   &lt;|&gt; ifExpression<br>   &lt;|&gt; zeroExpression<br>   &lt;|&gt; succExpression<br>   &lt;|&gt; predExpression<br>   &lt;|&gt; isZeroExpression<br>   &lt;|&gt; parens arithExpr<br>   &gt; "<span>expression</span>"<br><br><br><span>trueExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>true</span>"<br>     ; return TmTrue<br>     }<br><br><span>falseExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>false</span>"<br>     ; return TmFalse<br>     }<br><br><span>zeroExpression</span> <span>::</span> Parser ArithExpr<br><span>zeroExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>0</span>"<br>     ; return TmZero<br>     }<br><br><span>ifExpression</span> <span>::</span> Parser ArithExpr<br><span>ifExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>if</span>"<br>     ; condition <span>&lt;-</span> arithExpr<br>     ; reserved "<span>then</span>"<br>     ; thenClause <span>&lt;-</span> arithExpr<br>     ; reserved "<span>else</span>"<br>     ; elseClause <span>&lt;-</span> arithExpr<br>     ; return  (TmIfExpr condition thenClause elseClause)<br>     }<br><br><span>succExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>succ</span>"<br>     ; expr <span>&lt;-</span> arithExpr<br>     ; return  (TmSucc expr)<br>     }<br><br><span>predExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>pred</span>"<br>     ; expr <span>&lt;-</span> arithExpr<br>     ; return (TmPred expr)<br>     }<br><br><br><span>isZeroExpression</span> <span>=</span><br><span>do</span>{ reserved "<span>iszero</span>"<br>     ; expr <span>&lt;-</span> arithExpr<br>     ; return  (TmIsZero expr)<br>     }<br><br><br><br><span>-----------------------------------------------------------<br>-- Tokens<br>-- Use qualified import to have token parsers on toplevel<br>-----------------------------------------------------------<br></span><span>tokenParser</span>     <span>=</span> P.makeTokenParser haskellStyle  <br><br><span>parens</span>          <span>=</span> P.parens tokenParser   <br><span>braces</span>          <span>=</span> P.braces tokenParser   <br><span>semiSep1</span>        <span>=</span> P.semiSep1 tokenParser   <br><span>whiteSpace</span>      <span>=</span> P.whiteSpace tokenParser   <br><span>symbol</span>          <span>=</span> P.symbol tokenParser   <br><span>identifier</span>      <span>=</span> P.identifier tokenParser   <br><span>reserved</span>        <span>=</span> P.reserved tokenParser   <br><span>natural</span>         <span>=</span> P.natural tokenParser   <br><span>charLiteral</span>     <span>=</span> P.charLiteral tokenParser   <br><span>stringLiteral</span>   <span>=</span> P.stringLiteral tokenParser   <br></pre><br>Arith.hs<br><pre><br><span>module</span> <span>Arith</span> <span>where</span><br><br><br><br><span>data</span> <span>ArithExpr</span><br><span>=</span> <span>TmTrue</span><br><span>|</span> <span>TmFalse</span><br><span>|</span> <span>TmIfExpr</span> <span>ArithExpr</span> <span>ArithExpr</span> <span>ArithExpr</span><br><span>|</span> <span>TmZero</span><br><span>|</span> <span>TmSucc</span> <span>ArithExpr</span><br><span>|</span> <span>TmPred</span> <span>ArithExpr</span><br><span>|</span> <span>TmIsZero</span> <span>ArithExpr</span><br><span>deriving</span> (<span>Show</span>, <span>Eq</span>)<br><br><span>isNumericalVal</span> <span>::</span> <span>ArithExpr</span> <span>-&gt;</span> <span>Bool</span><br><span>isNumericalVal</span> <span>TmZero</span>     <span>=</span> <span>True</span><br><span>isNumericalVal</span> (<span>TmSucc</span> t) <span>=</span> isNumericalVal t<br><span>isNumericalVal</span> (<span>TmPred</span> t) <span>=</span> isNumericalVal t<br><span>isNumericalVal</span> <span>_</span>          <span>=</span> <span>False</span><br><br><br><br><span>isVal</span> <span>::</span> <span>ArithExpr</span> <span>-&gt;</span> <span>Bool</span><br><span>isVal</span> <span>TmTrue</span> <span>=</span> <span>True</span><br><span>isVal</span> <span>TmFalse</span> <span>=</span> <span>True</span><br><span>isVal</span> t<br><span>|</span> isNumericalVal t <span>=</span> <span>True</span><br><span>|</span> not (isNumericalVal t) <span>=</span> <span>False</span><br><span>isVal</span> <span>_</span> <span>=</span> <span>False</span><br><br><br><br><span>eval1</span> <span>::</span> <span>ArithExpr</span> <span>-&gt;</span> <span>Maybe</span> <span>ArithExpr</span><br><br><span>eval1</span> (<span>TmIfExpr</span> <span>TmTrue</span>  t <span>_</span>) <span>=</span> <span>Just</span> t<br><br><span>eval1</span> (<span>TmIfExpr</span> <span>TmFalse</span> <span>_</span> t) <span>=</span> <span>Just</span> t<br><br><span>eval1</span> (<span>TmIfExpr</span> t1 t2 t3) <span>=</span><br><span>let</span> t1' <span>=</span> eval1 t1<br><span>in</span>  <span>case</span> t1' <span>of</span><br>          { <span>Just</span> t1'' <span>-&gt;</span> <span>Just</span> <span>$</span> <span>TmIfExpr</span> t1'' t2 t3<br>          ; <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span> <span>--Just $ TmIfExpr t1 t2 t3<br></span>            }<br><br><span>eval1</span> (<span>TmSucc</span> t) <span>=</span><br><span>let</span> t' <span>=</span> eval1 t<br><span>in</span>  <span>case</span> t' <span>of</span><br>        { <span>Just</span> t'' <span>-&gt;</span> <span>Just</span> <span>$</span> <span>TmSucc</span> t''<br>        ; <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span> <span>--Just $ TmSucc t<br></span>          }<br><br><span>eval1</span> (<span>TmPred</span> <span>TmZero</span>) <span>=</span> <span>Just</span> <span>TmZero</span><br><br><span>eval1</span> (<span>TmPred</span> (<span>TmSucc</span> t))<br><span>|</span> isNumericalVal t <span>=</span> <span>Just</span> t<br><br><span>eval1</span> (<span>TmPred</span> t) <span>=</span><br><span>let</span> t' <span>=</span> eval1 t<br><span>in</span> <span>case</span> t' <span>of</span><br>       { <span>Just</span> t'' <span>-&gt;</span> <span>Just</span> <span>$</span> <span>TmPred</span> t''<br>       ; <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span> <span>-- Just $ TmPred t<br></span>         }<br><br><span>eval1</span> (<span>TmIsZero</span> <span>TmZero</span>) <span>=</span> <span>Just</span> <span>TmTrue</span><br><br><span>eval1</span> (<span>TmIsZero</span> (<span>TmSucc</span> t))<br><span>|</span> isNumericalVal t <span>=</span> <span>Just</span> <span>TmFalse</span><br><br><span>eval1</span> (<span>TmIsZero</span> t) <span>=</span><br><span>let</span> t' <span>=</span> eval1 t<br><span>in</span> <span>case</span> t' <span>of</span><br>       { <span>Just</span> t'' <span>-&gt;</span> <span>Just</span> <span>$</span> <span>TmIsZero</span> t''<br>       ; <span>Nothing</span> <span>-&gt;</span> <span>Nothing</span> <span>-- Just $ TmIsZero t<br></span>         }<br><br><span>eval1</span> <span>_</span> <span>=</span> <span>Nothing</span><br><br><span>eval</span> t <span>=</span><br><span>let</span> t' <span>=</span> eval1 t<br><span>in</span> <span>case</span> t' <span>of</span><br>       { <span>Just</span> t'' <span>-&gt;</span> eval t'' <span>--if (t /= t'') then eval t'' else t<br></span>         ; <span>Nothing</span> <span>-&gt;</span> t<br>       }<br></pre><br><br><br></pre></pre></body></html>