<html><body><a href="http://www.dehora.net/journal/2006/02/i_think_i_figured_out_the_list_comprehensions_thing_1.html">Bill de hÓra: I think I figured out the list comprehensions thing...</a><br><br>I've been trying to understand this stuff myself, and Bill de hÓra's post has prodded me to write this down so I won't forget it again.<br><br>List comprehensions are really just syntatic sugar. And too much syntatic sugar can cause truth decay.<br><br>List comprehensions are forms in functional and related languages that allow you to generate an entire list with a description of the list. So, for example, I can get a list of the first 10 squares by:<br><div><blockquote>[ x * x | x [1,4,9,16,25,36,49,64,81,100]<br><br>That gives me a list of the squares of x, where x is an element of the list of integers from 1 to 10.  I can also add some more qualifiers, like<br><br><blockquote>[ x * x | x 3] </blockquote>
<br>[16,25,36,49,64,81,100]<br><br><br><blockquote>[i * j | i 5]</blockquote>[5,8,10,9,12,15,8,12,16,20,5,10,15,20,25]<br><br>This is all pretty neat, but what does it really mean?<br><br>You 'normally'  think of drawing a variable from each of the generating lists, with the right most one varying most quickly, and skipping if the variables fail to meet the condition. This provides a natural analogue to the looping constructs in most programming languages.<br><blockquote>
<pre><span>for (int i = 1; i <br><span> for (int j = 1; j <br><span>      if ((i + j) &gt; 5) {</span><br><span>            list.push(i*j);</span><br><span>        }</span><br><span>    }</span><br><span>}</span><br></span></span></pre>
<br>
</blockquote>That close, natural, analogue can be a code smell in functional programming. It may be an indication that you're thinking of the problem in terms of loops, updating variables, etc.<br><br>The intent of list comprehension is to simulate loops and conditions, but it can be defined in terms of map and list concat. (As far as I can tell, this is due to <a href="http://homepages.inf.ed.ac.uk/wadler/">P. Wadler</a>, in <a href="http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/slpj-book-1987.pdf">Simon Peyton-Jones's The Implementation of Functional Programming Languages</a> )<br><br><pre><br>[t | x   map (\x -&gt; t) u<br>[t | p, q]    ==&gt;  concat [ [t | q] | p ]<br>[t | b ]      ==&gt;  if (b) then [t] else []<br></pre>
<br>Note that the two qualifications p and q are reversed when translated.<br><br>concat will take the results of the simplified comprehension and concatenate all of the resulting lists together, eliminating empty lists.<br><br>Lets take the first, simple, example:<br><blockquote> [ x * x | x that translates to:<br><blockquote> map (\x -&gt; x * x) [1..10]</blockquote>The next example<br><blockquote>[ x * x | x 3]</blockquote>takes a few more steps<br><br>  concat [ [x * x | x&gt; 3] | x <br>concat ( map (\x -&gt; [x * x | x&gt;3]) [1..10] )<br><br>concat (map (\x -&gt; (if (x&gt;3) then [x*x] else [])) [1..10])<br><br>In this case, the list comprehension is more concise. On the other hand, the expanded version is a bit more suggestive. Particularly if I'm willing for it <span>not </span>to be a lambda expression.<br><br><br><br>
</blockquote>
</blockquote></div></body></html>