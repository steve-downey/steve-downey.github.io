<html><body><p>These are the exercises from chapter 3 of<br><a href="http://book.realworldhaskell.org/">Real World Haskell<br>by Bryan O'Sullivan, Don Stewart, and John Goerzen<br></a><br>&gt; module RWHChapter3 where<br><br>{-# OPTIONS_GHC -XMagicHash #-}<br><br><br>Some useful things to check my work:<br><br>&gt; import Test.QuickCheck<br>&gt; import Data.List<br>&gt; import GHC.Prim<br>&gt; import GHC.Base<br><br>1) Write a function that computes the number of elements in a list. To test it, ensure that it gives the same answers as the standard length  function.<br><br>&gt; lengthList (x:xs) = 1 + lengthList xs<br>&gt; lengthList []     = 0<br><br>check that it works by running<br><br>quickCheck (\s -&gt; length s == lengthList s)<br><br>at the interactive prompt<br><br><br><br>&gt; ghclength l                =  len l 0#<br>&gt;     where<br>&gt;     len :: [a] -&gt; Int# -&gt; Int<br>&gt;     len []     a# = I# a#<br>&gt;     len (_:xs) a# = len xs (a# +# 1#)<br><br>is the definition used by GHC.<br>It doesn't stack overflow on ghclength [1..1000000]<br>lengthList [1..1000000] does, at least in ghci<br><br><br>2) Add a type signature for your function to your source file.<br><br>&gt; lengthList :: [a] -&gt; Integer<br><br><br>3. write a function that computes the mean of a list, i.e. the sum of all elements in the list divided by its length. (you may need to use the fromintegral function to convert the length of the list from an integer into a floating point number.)<br><br>&gt; listMean x = sum x / fromIntegral (length x)<br><br>4. Turn a list into a palindrome, i.e. it should read the same both backwards and forwards. For example, given the list [1,2,3], your function should return [1,2,3,3,2,1].<br><br>&gt; makePalindrome x = x ++ reverse x<br><br><br>5. Write a function that determines whether its input list is a palindrome.<br><br>&gt; testPalindrome x = x == reverse x<br><br>&gt; testPalindrome2 x = (take (halfLength x) x)<br>&gt;                     == (take (halfLength x) (reverse x))<br>&gt;     where halfLength x = ((length x) `quot` 2)<br><br>reversing the whole list isn't exactly right<br><br>&gt; testPalindrome3 x = (take (halfLength x) x)<br>&gt;                     == reverse (drop (halfLength x) x)<br>&gt;     where halfLength x = ((length x) `quot` 2)<br><br>except now it thinks that odd length lists aren't palindromes.<br><br>6. Create a function that sorts a list of lists based on the length of each sublist. (You may want to look at the sortBy function from the Data.List module.)<br><br>&gt; sortByLength  = sortBy (\a b -&gt; compare (length a) (length b))<br><br>7 An intersperse with type intersperse :: a -&gt; [[a]] -&gt; [a], such that<br>ghci&gt; myintersperse ',' []<br>""<br>ghci&gt; myintersperse ',' ["foo"]<br>"foo"<br>ghci&gt; myintersperse ',' ["foo","bar","baz","quux"]<br>"foo,bar,baz,quux"<br><br>&gt; myintersperse :: a -&gt; [[a]] -&gt; [a]<br>&gt; myintersperse _ [] = []<br>&gt; myintersperse _ [x] = x<br>&gt; myintersperse c (x:xs) = x ++ [c] ++ (myintersperse c xs)<br><br>8. Height of a tree<br><br>&gt; data Tree a = Node a (Tree a) (Tree a)<br>&gt;             | Empty<br>&gt;               deriving (Show)<br><br>depth' :: Tree a -&gt; Int<br><br>&gt; depth' Empty      = 0<br>&gt; depth' (Node _ b c) = 1 + (max (depth' b) (depth' c))<br><br><br>9. Consider three two-dimensional points a, b, and c. If we look at the angle formed by the line segment from a to b and the line segment from b to c, it either turns left, turns right, or forms a straight line. Define a Direction data type that lets you represent these possibilities.<br><br>&gt; data Direction = DLeft<br>&gt;                | DRight<br>&gt;                | DStraight<br>&gt;                  deriving (Show)<br><br>&gt; data Point = Point {<br>&gt;       x::Double,<br>&gt;       y::Double<br>&gt;     } deriving (Show)<br><br>10. Write a function that takes three 2D Points and returns a direction.<br><br>&gt; direction p1 p2 p3<br>&gt;     |  signCross p1 p2 p3 &gt;     |  signCross p1 p2 p3 &gt; 0 = DLeft<br>&gt;     |  signCross p1 p2 p3 == 0 = DStraight<br>&gt;     where signCross (Point x1 y1) (Point x2 y2) (Point x3 y3) =<br>&gt;               (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)<br><br><br>11. Define a function that takes a list of 2D points and computes the direction of each successive triple. Given a list of points [a,b,c,d,e], it should begin by computing the turn made by [a,b,c], then the turn made by [b,c,d], then [c,d,e]. Your function should return a list of Direction.<br><br>&gt; directionList :: [Point] -&gt; [Direction]<br>&gt; directionList ([]) = []<br>&gt; directionList (_:[]) = []<br>&gt; directionList (_:_:[]) = []<br>&gt; directionList (x:x':x'':[]) = [(direction x x' x'')]<br>&gt; directionList (x:x':x'':xs) = (direction x x' x'') : directionList (x':x'':xs)<br><br><br>I don't particularly like the pattern match on the three x's. How<br>about a more general function to do sliding windows of data across the<br>list?<br><br>&gt; window :: Int -&gt; [a] -&gt; [[a]]<br>&gt; window2 :: Int -&gt; [a] -&gt; [[a]]<br><br><br>&gt; window n xs = if (length xs) &gt;               then []<br>&gt;               else (take n xs) : window n (tail xs)<br><br>&gt; window2 n xs  |  (length xs) &gt; window2 n x@(_:xs)                  = (take n x) : window2 n xs<br><br>&gt; direction2 (x1:x2:x3:[]) = direction x1 x2 x3<br><br>&gt; directionList2' (x:xs) = direction2 x : directionList2' xs<br>&gt; directionList2' [] = []<br><br>&gt; directionList2 x = directionList2' (window2 3 x)<br><br><br><br>I'm still working on the convex hull problem</p></body></html>