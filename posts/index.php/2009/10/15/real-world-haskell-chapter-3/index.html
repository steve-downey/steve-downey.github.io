<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Real World Haskell - Chapter 3 | What Comes to Mind</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer">
<link rel="stylesheet" href="../../../../../../assets/css/rst.min.css">
<link rel="stylesheet" href="../../../../../../assets/css/foundation.min.css">
<link rel="stylesheet" href="../../../../../../assets/css/app.css">
<link rel="stylesheet" href="../../../../../../assets/css/modus-vivendi-tinted.css">
<link href="../../../../../../assets/css/custom.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../../../rss.xml">
<link rel="alternate" type="application/atom+xml" title="Atom" href="../../../../../../feed.atom">
<link rel="canonical" href="https://sdowney.org/posts/index.php/2009/10/15/real-world-haskell-chapter-3/">
<!--[if lt IE 9]><script src="../../../../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Steve Downey">
<link rel="prev" href="../../01/testing-embedded-tex/" title="Testing embedded TeX" type="text/html">
<link rel="next" href="../../../../2013/03/25/hello-world-2/" title="Hello world!" type="text/html">
<meta property="og:site_name" content="What Comes to Mind">
<meta property="og:title" content="Real World Haskell - Chapter 3">
<meta property="og:url" content="https://sdowney.org/posts/index.php/2009/10/15/real-world-haskell-chapter-3/">
<meta property="og:description" content="These are the exercises from chapter 3 ofReal World Haskellby Bryan O'Sullivan, Don Stewart, and John Goerzen&gt; module RWHChapter3 where{-# OPTIONS_GHC -XMagicHash #-}Some useful things to check my wor">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2009-10-15T22:06:00-04:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@sdowney.org">
<meta name="twitter:creator" content="@sdowney">
</head>
<body>

    

    
<div class="top-bar">
<div class="top-bar-left">
<ul class="menu">
<li class="menu-text"><a href="https://sdowney.org/" title="What Comes to Mind" rel="home">What Comes to Mind</a></li>
                <li><a href="../../../../../../archive.html">Archives</a></li>
                <li><a href="../../../../../../categories/index.html">Tags</a></li>
                <li><a href="mailto:sdowney@sdowney.dev"><i class="fa fa-envelope"></i></a></li>
                <li><a href="https://github.com/steve-downey">GitHub <i class="fa-brands fa-square-github"></i></a></li>
                <li><a href="https://mastodon.social/@Sdowney">Mastodon <i class="fa-brands fa-mastodon"></i></a></li>
                <li><a href="https://bsky.app/profile/sdowney.bsky.social">Bluesky <i class="fa-brands fa-square-bluesky"></i></a></li>
                <li><a href="../../../../../../feed.atom">ATOM <i class="fa-solid fa-atom"></i></a></li>
                <li><a href="../../../../../../rss.xml">RSS <i class="fa-solid fa-rss"></i></a></li>
    
    
    </ul>
</div>
</div>

    

<div class="callout large primary">
<div class="row column text-center">

    <h1>Real World Haskell - Chapter 3</h1>
    <h2 class="subheader"><small>2009-10-15 22:06</small></h2>

</div>
</div>

<div class="row medium-8 large-7 columns">

<div class="blog-post">
    
    


    <p>These are the exercises from chapter 3 of<br><a href="http://book.realworldhaskell.org/">Real World Haskell<br>by Bryan O'Sullivan, Don Stewart, and John Goerzen<br></a><br>&gt; module RWHChapter3 where<br><br>{-# OPTIONS_GHC -XMagicHash #-}<br><br><br>Some useful things to check my work:<br><br>&gt; import Test.QuickCheck<br>&gt; import Data.List<br>&gt; import GHC.Prim<br>&gt; import GHC.Base<br><br>1) Write a function that computes the number of elements in a list. To test it, ensure that it gives the same answers as the standard length  function.<br><br>&gt; lengthList (x:xs) = 1 + lengthList xs<br>&gt; lengthList []     = 0<br><br>check that it works by running<br><br>quickCheck (\s -&gt; length s == lengthList s)<br><br>at the interactive prompt<br><br><br><br>&gt; ghclength l                =  len l 0#<br>&gt;     where<br>&gt;     len :: [a] -&gt; Int# -&gt; Int<br>&gt;     len []     a# = I# a#<br>&gt;     len (_:xs) a# = len xs (a# +# 1#)<br><br>is the definition used by GHC.<br>It doesn't stack overflow on ghclength [1..1000000]<br>lengthList [1..1000000] does, at least in ghci<br><br><br>2) Add a type signature for your function to your source file.<br><br>&gt; lengthList :: [a] -&gt; Integer<br><br><br>3. write a function that computes the mean of a list, i.e. the sum of all elements in the list divided by its length. (you may need to use the fromintegral function to convert the length of the list from an integer into a floating point number.)<br><br>&gt; listMean x = sum x / fromIntegral (length x)<br><br>4. Turn a list into a palindrome, i.e. it should read the same both backwards and forwards. For example, given the list [1,2,3], your function should return [1,2,3,3,2,1].<br><br>&gt; makePalindrome x = x ++ reverse x<br><br><br>5. Write a function that determines whether its input list is a palindrome.<br><br>&gt; testPalindrome x = x == reverse x<br><br>&gt; testPalindrome2 x = (take (halfLength x) x)<br>&gt;                     == (take (halfLength x) (reverse x))<br>&gt;     where halfLength x = ((length x) `quot` 2)<br><br>reversing the whole list isn't exactly right<br><br>&gt; testPalindrome3 x = (take (halfLength x) x)<br>&gt;                     == reverse (drop (halfLength x) x)<br>&gt;     where halfLength x = ((length x) `quot` 2)<br><br>except now it thinks that odd length lists aren't palindromes.<br><br>6. Create a function that sorts a list of lists based on the length of each sublist. (You may want to look at the sortBy function from the Data.List module.)<br><br>&gt; sortByLength  = sortBy (\a b -&gt; compare (length a) (length b))<br><br>7 An intersperse with type intersperse :: a -&gt; [[a]] -&gt; [a], such that<br>ghci&gt; myintersperse ',' []<br>""<br>ghci&gt; myintersperse ',' ["foo"]<br>"foo"<br>ghci&gt; myintersperse ',' ["foo","bar","baz","quux"]<br>"foo,bar,baz,quux"<br><br>&gt; myintersperse :: a -&gt; [[a]] -&gt; [a]<br>&gt; myintersperse _ [] = []<br>&gt; myintersperse _ [x] = x<br>&gt; myintersperse c (x:xs) = x ++ [c] ++ (myintersperse c xs)<br><br>8. Height of a tree<br><br>&gt; data Tree a = Node a (Tree a) (Tree a)<br>&gt;             | Empty<br>&gt;               deriving (Show)<br><br>depth' :: Tree a -&gt; Int<br><br>&gt; depth' Empty      = 0<br>&gt; depth' (Node _ b c) = 1 + (max (depth' b) (depth' c))<br><br><br>9. Consider three two-dimensional points a, b, and c. If we look at the angle formed by the line segment from a to b and the line segment from b to c, it either turns left, turns right, or forms a straight line. Define a Direction data type that lets you represent these possibilities.<br><br>&gt; data Direction = DLeft<br>&gt;                | DRight<br>&gt;                | DStraight<br>&gt;                  deriving (Show)<br><br>&gt; data Point = Point {<br>&gt;       x::Double,<br>&gt;       y::Double<br>&gt;     } deriving (Show)<br><br>10. Write a function that takes three 2D Points and returns a direction.<br><br>&gt; direction p1 p2 p3<br>&gt;     |  signCross p1 p2 p3 &gt;     |  signCross p1 p2 p3 &gt; 0 = DLeft<br>&gt;     |  signCross p1 p2 p3 == 0 = DStraight<br>&gt;     where signCross (Point x1 y1) (Point x2 y2) (Point x3 y3) =<br>&gt;               (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)<br><br><br>11. Define a function that takes a list of 2D points and computes the direction of each successive triple. Given a list of points [a,b,c,d,e], it should begin by computing the turn made by [a,b,c], then the turn made by [b,c,d], then [c,d,e]. Your function should return a list of Direction.<br><br>&gt; directionList :: [Point] -&gt; [Direction]<br>&gt; directionList ([]) = []<br>&gt; directionList (_:[]) = []<br>&gt; directionList (_:_:[]) = []<br>&gt; directionList (x:x':x'':[]) = [(direction x x' x'')]<br>&gt; directionList (x:x':x'':xs) = (direction x x' x'') : directionList (x':x'':xs)<br><br><br>I don't particularly like the pattern match on the three x's. How<br>about a more general function to do sliding windows of data across the<br>list?<br><br>&gt; window :: Int -&gt; [a] -&gt; [[a]]<br>&gt; window2 :: Int -&gt; [a] -&gt; [[a]]<br><br><br>&gt; window n xs = if (length xs) &gt;               then []<br>&gt;               else (take n xs) : window n (tail xs)<br><br>&gt; window2 n xs  |  (length xs) &gt; window2 n x@(_:xs)                  = (take n x) : window2 n xs<br><br>&gt; direction2 (x1:x2:x3:[]) = direction x1 x2 x3<br><br>&gt; directionList2' (x:xs) = direction2 x : directionList2' xs<br>&gt; directionList2' [] = []<br><br>&gt; directionList2 x = directionList2' (window2 3 x)<br><br><br><br>I'm still working on the convex hull problem</p>

    <div class="callout">
    <ul class="menu simple">
<li>Author: Steve Downey</li>

    </ul>
</div>
    

    
        <div class="column row">
            <ul class="pagination" role="navigation" aria-label="Pagination">
<li>
                    <a href="../../01/testing-embedded-tex/" rel="prev" title="Testing embedded TeX">« <span class="show-for-sr">Previous post</span></a>
                </li>
                <li>
                    <a href="../../../../2013/03/25/hello-world-2/" rel="next" title="Hello world!" aria-label="Next page">» <span class="show-for-sr">Next post</span></a>
                </li>
            </ul>
</div>

    
    


</div>



<hr>
<footer id="footer"><p><small>Contents © 2025         <a href="mailto:sdowney@sdowney.dev">Steve Downey</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a> - 
 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
 <img alt="Creative Commons License BY-NC-SA" style="border-width:0; margin-bottom:12px;" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a></small></p>
            
        </footer>
</div>

    



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VGV27RDN3E"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VGV27RDN3E');
</script>
</body>
</html>
