<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Stuff, and more stuff">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>What Comes to Mind (old posts, page 8) | What Comes to Mind</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.1/css/all.min.css" crossorigin="anonymous">
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="rss.xml">
<link rel="alternate" type="application/atom+xml" title="Atom" hreflang="en" href="feed.atom">
<link rel="canonical" href="https://sdowney.org/index-8.html">
<link rel="prev" href="index-9.html" type="text/html">
<link rel="next" href="index-7.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href=".">

            <span id="blog-title">What Comes to Mind</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav"></ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="archive.html" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="categories/index.html" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="mailto:sdowney@sdowney.dev" class="nav-link"><i class="fa fa-envelope"></i></a>
                </li>
<li class="nav-item">
<a href="https://github.com/steve-downey" class="nav-link">GitHub <i class="fa-brands fa-square-github"></i></a>
                </li>
<li class="nav-item">
<a href="https://mastodon.social/@Sdowney" class="nav-link">Mastodon <i class="fa-brands fa-mastodon"></i></a>
                </li>
<li class="nav-item">
<a href="https://bsky.app/profile/sdowney.bsky.social" class="nav-link">Bluesky <i class="fa-brands fa-square-bluesky"></i></a>
                </li>
<li class="nav-item">
<a href="feed.atom" class="nav-link">ATOM <i class="fa-solid fa-atom"></i></a>
                </li>
<li class="nav-item">
<a href="rss.xml" class="nav-link">RSS <i class="fa-solid fa-rss"></i></a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
    
        

    
        
    <div class="postindex">
            <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2018/06/05/multithread-experiments/" class="u-url">Multithread Experiments</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2018/06/05/multithread-experiments/" rel="bookmark">
            <time class="published dt-published" datetime="2018-06-05T00:00:00-04:00" itemprop="datePublished" title="2018-06-05 00:00">2018-06-05 00:00</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <div id="outline-container-org43806e8" class="outline-2">
<h3 id="org43806e8">An Experiment Collects Samples</h3>
<div class="outline-text-2" id="text-org43806e8">
 I'm modelling this in order to run bits of code like the various litmus tests used to describe multi-core architectures. A set of functions to be run in parallel that may or may not write to a result, which type is a property of the Test being run. The Experiment will run the Test collecting Samples. The Test type will provide a tuple of functions to run. They will be run under a spingate in all permutations in order to remove scheduling bias. 
</div>
</div>

<div id="outline-container-org699e7ae" class="outline-2">
<h3 id="org699e7ae">What a Test looks like</h3>
<div class="outline-text-2" id="text-org699e7ae">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">MP</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">Message Passing</span>
    <span class="org-type">int</span> <span class="org-variable-name">x_</span>;
    <span class="org-type">int</span> <span class="org-variable-name">y_</span>;

  <span class="org-keyword">public</span>:
    <span class="org-keyword">typedef</span> <span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;<span class="org-type">int</span>&gt; <span class="org-type">Result</span>;
    <span class="org-function-name">MP</span>();
    <span class="org-type">void</span> <span class="org-function-name">t1</span>();
    <span class="org-type">void</span> <span class="org-function-name">t2</span>(<span class="org-type">Result</span>&amp; <span class="org-variable-name">read</span>);

    <span class="org-keyword">auto</span> <span class="org-function-name">actions</span>() {
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_tuple([<span class="org-keyword">this</span>]() { t1(); },
                               [<span class="org-keyword">this</span>](<span class="org-type">Result</span>&amp; <span class="org-variable-name">result</span>) { t2(result); });
    }
};
</pre>
</div>

 The Test interface must provide a Result type, and an actions() member that will produce a tuple of functions to run which either take no arguments or a reference to a result. 

 The test being defined here is the basic Message Passing litmus test. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-constant">MP</span>::<span class="org-function-name">MP</span>() : x_(0), y_(0) {}

<span class="org-type">void</span> <span class="org-constant">MP</span>::<span class="org-function-name">t1</span>() {
    x_ = 1;
    y_ = 1;
}

<span class="org-type">void</span> <span class="org-constant">MP</span>::<span class="org-function-name">t2</span>(<span class="org-type">Result</span>&amp; <span class="org-variable-name">read</span>) {
    <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>y) {
    }
    <span class="org-constant">std</span>::get&lt;0&gt;(read) = x_;
}
</pre>
</div>

 Two variables are initialized to 0. One thread stores 1 to x first, then to 1 to y. The other thread loops until it reads a non-zero in y, and then reads x. The value in x is the message being passed between threads. 

 In an actual test, the variables would be atomics, specifiying load and store strength, and the variables might have constraints on layout to help sharing cache line updates. 
</div>
</div>

<div id="outline-container-org991602e" class="outline-2">
<h3 id="org991602e">An Experiment</h3>
<div class="outline-text-2" id="text-org991602e">
 An Experiment samples a test a number of times. It takes the result of each sample, and puts in a map of the results to count, incrementing the count for each distinct result. The actions to run are permuted each time, to help remove bias about which action is loaded behind the spingate first. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">Experiment</span>::<span class="org-function-name">run</span>(<span class="org-type">size_t</span> <span class="org-variable-name">count</span>) {
    <span class="org-keyword">using</span> <span class="org-type">Actions</span> = <span class="org-keyword">decltype</span>(<span class="org-constant">std</span>::declval&lt;Test&gt;().actions());
    <span class="org-keyword">auto</span> <span class="org-variable-name">getters</span> = <span class="org-constant">tupleutil</span>::tuple_getters&lt;<span class="org-type">Actions</span>&gt;();
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; count; ++i) {
        <span class="org-type">Sample</span>&lt;Test&gt; <span class="org-variable-name">sample</span>;
        sample.run(getters);
        resultMap_[sample.result_]++;
        <span class="org-constant">std</span>::next_permutation(getters.begin(), getters.end());
    }
}

</pre>
</div>
 <code>tupleutil::tuple_getters</code> returns an array of getters each of which returns a std::variant&lt;Types…&gt; with the same parameter pack as the tuple. 

 Sample runs all of the actions in a batch that locks them behind a spingate, and collects the results for each action. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">Test</span>&gt; <span class="org-keyword">class</span> <span class="org-type">Sample</span> {
  <span class="org-keyword">public</span>:
    <span class="org-type">Batch</span>                 <span class="org-variable-name">batch_</span>;
    <span class="org-type">Test</span>                  <span class="org-variable-name">test_</span>;
    <span class="org-keyword">typename</span> <span class="org-constant">Test</span>::<span class="org-type">Result</span> <span class="org-variable-name">result_</span>;

    <span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">V</span>, <span class="org-type">size_t</span> <span class="org-variable-name">I</span>&gt; <span class="org-type">void</span> <span class="org-function-name">run</span>(<span class="org-constant">std</span>::<span class="org-type">array</span>&lt;<span class="org-type">V</span>, I&gt; <span class="org-keyword">const</span>&amp; <span class="org-variable-name">getters</span>) {
        <span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">actions</span> = test_.actions();
        add(actions, getters);
        batch_.run();
    }
};
</pre>
</div>

 Add is a templated member function that loops over the array, uses the getter to pull a function out of the tuple of actions and visits that with a lambda that will add either the function with no arguments, or that function with a reference to the results, to the batch. 

<div class="org-src-container">
<pre class="src src-C++">    <span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Tuple</span>, <span class="org-keyword">typename</span> <span class="org-type">Variant</span>, <span class="org-type">size_t</span> <span class="org-variable-name">I</span>&gt;
    <span class="org-type">void</span> <span class="org-function-name">add</span>(<span class="org-type">Tuple</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">actions</span>, <span class="org-constant">std</span>::<span class="org-type">array</span>&lt;<span class="org-type">Variant</span>, I&gt; <span class="org-keyword">const</span>&amp; <span class="org-variable-name">getters</span>) {
        <span class="org-keyword">auto</span> <span class="org-variable-name">adder</span> = [<span class="org-keyword">this</span>](<span class="org-keyword">auto</span>&amp;&amp; <span class="org-variable-name">f</span>) {
            <span class="org-keyword">using</span> <span class="org-type">F</span> = <span class="org-constant">std</span>::<span class="org-type">remove_cv_t</span>&lt;<span class="org-constant">std</span>::<span class="org-type">remove_reference_t</span>&lt;<span class="org-keyword">decltype</span>(f)&gt;&gt;;
            <span class="org-keyword">if</span> <span class="org-keyword">constexpr</span> (<span class="org-constant">std</span>::<span class="org-type">is_invocable_v</span>&lt;<span class="org-type">F</span>&gt;) {
                batch_.add(f);
            } <span class="org-keyword">else</span> {
                batch_.add(f, <span class="org-constant">std</span>::ref(result_));
            }
        };
        <span class="org-keyword">for</span> (<span class="org-keyword">auto</span>&amp;&amp; <span class="org-variable-name">get_n</span> : getters) {
            <span class="org-constant">std</span>::visit(adder, get_n(actions));
        }
        <span class="org-keyword">return</span>;
    }
</pre>
</div>

 I am a bit dissatisfied with the else case not being constexpr if followed by a static assert, but getting the condition right didn't work the obvious way, so I punted. There will be a compiler error if f(result_) can't actually be called by the batch. 
</div>
</div>

<div id="outline-container-org3e10cba" class="outline-2">
<h3 id="org3e10cba">Batch recapped:</h3>
<div class="outline-text-2" id="text-org3e10cba">
 The key bit of code is 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">Function</span>, <span class="org-keyword">class</span><span class="org-function-name">...</span> <span class="org-type">Args</span>&gt;
<span class="org-type">void</span> <span class="org-constant">Batch</span>::<span class="org-function-name">add</span>(<span class="org-type">Function</span>&amp;&amp; <span class="org-variable-name">f</span>, <span class="org-type">Args</span>&amp;&amp;<span class="org-function-name">...</span> <span class="org-variable-name">args</span>) {
    workers_.emplace_back([ <span class="org-keyword">this</span>, <span class="org-variable-name">f</span> = <span class="org-constant">std</span>::forward&lt;<span class="org-type">Function</span>&gt;(f), <span class="org-constant">args</span><span class="org-function-name">...</span> ]() {
            gate_.wait();
            f(args<span class="org-function-name">...</span>);
        });
}

</pre>
</div>

 Batch has a spingate and runs all of the functions that are added sitting behind it. The <code>run()</code> function opens the gate and joins all the worker threads. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">Batch</span>::<span class="org-function-name">run</span>() {
    gate_.open();
    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span>&amp; <span class="org-variable-name">thr</span> : workers_) {
        thr.join();
    }
}

</pre>
</div>
</div>
</div>

<div id="outline-container-orge172530" class="outline-2">
<h3 id="orge172530">Summary</h3>
<div class="outline-text-2" id="text-orge172530">
 With all the machinery in place, the test infrascructure can aggressively run multi-threaded tests, giving the thread scheduler the best opportunity to run all of the actions in any order. This allows multi thread bugs to be shaken out by looking for surprising results from the experiment. 
</div>
</div>

<div id="outline-container-orgc9ec895" class="outline-2">
<h3 id="orgc9ec895">Source Code</h3>
<div class="outline-text-2" id="text-orgc9ec895">
 Exported from an org-mode doc, experiment.org, which is available, with all of the source on github at <a href="https://github.com/steve-downey/spingate">SpinGate</a>. 
</div>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/296/" class="u-url">The Identity Monad</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/296/" rel="bookmark">
            <time class="published dt-published" datetime="2018-03-01T00:00:00-05:00" itemprop="datePublished" title="2018-03-01 00:00">2018-03-01 00:00</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p> A short exposition on the simplest monad possible, the Identity monad, which does nothing. It is a pure context, that provides no extra capabilites. The only reason to consider it is that it provides a fairly pure implementation of the monad interface, with no other distractions. The only known use for the Identity monad, other than exposition, is to model Taint, where the context, such as user input, can't be removed. </p>

<div id="outline-container-org09d1c70" class="outline-2">
<h3 id="org09d1c70">Identity Monad in Haskell</h3>
<div class="outline-text-2" id="text-org09d1c70">
<p> This is a definition of the Identity monad in haskell, for reference. This is using the relatively new Applicative typeclass between Functor and Monad. </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-haskell" id="nil">import Control.Monad

data Id a = Id a deriving Show

instance Functor Id where
    fmap f (Id x)   = Id (f x)

instance Applicative Id where
    pure x          = Id x
    Id f &lt;*&gt; Id x   = Id (f x)

instance Monad Id where
    (Id x) &gt;&gt;= f    = f x
</pre>
</div>

<p> Id wraps a single value. There is no empty state. The mapping function, fmap, simply applies the a funtion to the value being wrapped. The function (&lt;*&gt;), also known as ap, takes a wrapped function, applies it to a wrapped value, and returns it wrapped up. The function pure, which is the same as return, just constructs an Id with the value in it. The bind function (&gt;&gt;=) does the same thing, only with a function that returns a wrapped value. </p>
</div>
</div>



<div id="outline-container-org87576b1" class="outline-2">
<h3 id="org87576b1">Identity Monad in C++</h3>
<div class="outline-text-2" id="text-org87576b1">
<p> The basic data structure for the Identity monad is fairly trivial. It's a generic type, and holds a single element, privately, of that type. I am ignoring any issues about reference types, non-copyable types, non-moveable types, etc. as distractions. I'm also assuming it's default constructable, for simplicity. </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">Identity</span> {
    <span class="org-type">T</span> <span class="org-variable-name">t_</span>;

  <span class="org-keyword">public</span>:
    <span class="org-function-name">Identity</span>() : t_(){};
    <span class="org-function-name">Identity</span>(<span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">t</span>) : t_(t){};

    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
};

</pre>
</div>

<p> In particular, there are no accesors for the <code class="src src-C++"><span class="org-type">T</span> <span class="org-variable-name">t_</span></code> being held. Values go in but they can't get out. At least not yet, and not without side-effect using functions. This is why it's sometimes used as Taint, where you can not lose track of the data coming from outside and being untrusted. </p>
</div>
</div>


<div id="outline-container-org6bd987d" class="outline-2">
<h3 id="org6bd987d">Identity Functor</h3>
<div class="outline-text-2" id="text-org6bd987d">
<p> To make a data structure a Functor a <code class="src src-C++">fmap</code> function needs to be provided that satisfies certain requirements. It also turns out that if there is such a function, for a particular data struture, all of the implmentations are isomorphic. So there's basically only one for a particular data structure. Fmap for a functor F takes two arguments, a function from T-&gt;U, an F&lt;T&gt;, and it will return an F&lt;U&gt;. Although, for C++ this is a bit over-restrictive, and we probably want to be able to apply any function where the template type of the Identity can be used to call the function being mapped. Fortunately C++17 added some traits to work with invocables, and we can use <code class="src src-C++"><span class="org-constant">std</span>::invoke_result_t</code> to both detect if a call can be made, and determine the type of the result. </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">U</span>, <span class="org-keyword">typename</span> <span class="org-type">Func</span>&gt;
<span class="org-keyword">auto</span> <span class="org-function-name">fmap</span>(<span class="org-type">Identity</span>&lt;<span class="org-type">U</span>&gt; <span class="org-keyword">const</span>&amp; <span class="org-variable-name">i</span>, <span class="org-type">Func</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">f</span>)
    -&gt; <span class="org-type">Identity</span>&lt;<span class="org-constant">std</span>::<span class="org-type">invoke_result_t</span>&lt;<span class="org-type">Func</span>, <span class="org-type">U</span>&gt;&gt; {
    <span class="org-keyword">using</span> <span class="org-type">V</span> = <span class="org-constant">std</span>::<span class="org-type">invoke_result_t</span>&lt;<span class="org-type">Func</span>, <span class="org-type">U</span>&gt;;
    <span class="org-keyword">return</span> <span class="org-type">Identity</span>&lt;<span class="org-type">V</span>&gt;{<span class="org-constant">std</span>::invoke(f, i.t_)};
}

</pre>
</div>
<p> It's also declared as a friend, so that it can have access to the internally held t_. </p>

<p> There are two "laws" for how fmap must behave </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-haskell" id="nil">-- identity preserving
fmap id = id

-- Composition
fmap (f . g) = (fmap f) . (fmap g)
</pre>
</div>

<p> The first one says that fmaping the identity function won't change the object, so it's equivalent to just the identity function. For Identity, this is straightforward to show, since the held value isn't going to be changed, the result won't change the value of the Identity. We can write an equality test for Identity: </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-type">U</span>&gt;
<span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name">==</span>(<span class="org-type">Identity</span>&lt;<span class="org-type">T</span>&gt; <span class="org-variable-name">t</span>, <span class="org-type">Identity</span>&lt;<span class="org-type">U</span>&gt; <span class="org-variable-name">u</span>) {
    <span class="org-keyword">return</span> t.t_ == u.t_;
}

<span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-type">U</span>&gt;
<span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name">!=</span>(<span class="org-type">Identity</span>&lt;<span class="org-type">T</span>&gt; <span class="org-variable-name">t</span>, <span class="org-type">Identity</span>&lt;<span class="org-type">U</span>&gt; <span class="org-variable-name">u</span>) {
    <span class="org-keyword">return</span> <span class="org-negation-char">!</span>(t == u);
}
</pre>
</div>

<p> It's expressed as a non-member, in order to support allowed conversions between T and U. So we can compare Identity&lt;int&gt; and Identity&lt;long&gt; the same way we can compare int and long. </p>

<p> The second law is more interesting. It's expressing that you can distribute fmap over function composition. Chaining functions works transparently. with appropriate adjustment of the types of the functions. So what does applying fmap to a function, without a Functor object like Identity do? It's a higher order function, one that takes <span class="underline">and returns</span> a function. </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Func</span>&gt;
<span class="org-keyword">auto</span> <span class="org-function-name">fmap</span>(<span class="org-type">Func</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">f</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">maps (T -&gt; U) -&gt; (Identity&lt;T&gt; -&gt; Identity&lt;U&gt;)</span>
    <span class="org-keyword">return</span> [f](<span class="org-keyword">auto</span> <span class="org-variable-name">t</span>) { <span class="org-keyword">return</span> fmap(t, f); };
}

</pre>
</div>

<p> In haskell this is natuaral, and does not need a separate defintion because of currying. In haskell if you have a function of type (T -&gt; U) -&gt; F&lt;T&gt; -&gt; F&lt;U&gt;, it is both a function taking one argument, and returning a function, and a function taking two argument and returning a value. Both (T-&gt;U) -&gt; (F&lt;T&gt; -&gt; F&lt;U&gt;) and (T -&gt; U), F&lt;T&gt; -&gt; F&lt;U&gt; are true, depending on how many arguments you supply. </p>

<p> The operator (.) in haskell has type <code class="src src-haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code>, so f . g is g(f()), more function chaining. We can either lift the the function (a -&gt; c) into F&lt;a&gt; -&gt; F&lt;c&gt;, or we can chain together F&lt;a&gt; -&gt; F&lt;b&gt; into F&lt;b&gt; -&gt; F&lt;c&gt; and get the same result. This is a natural property of container-like Functors, like Identity, or an optional, or std::vector. </p>
</div>
</div>

<div id="outline-container-org210ebb3" class="outline-2">
<h3 id="org210ebb3">Identity function digression</h3>
<div class="outline-text-2" id="text-org210ebb3">
<p> It's surprisingly tricky to get a good identity function, one that really returns the same object in the C++ sense.  This is the one I use: </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">identity</span> = [](<span class="org-keyword">auto</span> &amp;&amp;<span class="org-variable-name">v</span>) -&gt; <span class="org-keyword">decltype</span>(<span class="org-keyword">auto</span>)
{
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::forward&lt;<span class="org-keyword">decltype</span>(v)&gt;(v);
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgffcca90" class="outline-2">
<h3 id="orgffcca90">Using fmap on Identity</h3>
<div class="outline-text-2" id="text-orgffcca90">
<p> A short example, from a test case of using the two argument fmap: </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-type">Identity</span>&lt;<span class="org-type">int</span>&gt;  <span class="org-variable-name">i</span>;
<span class="org-type">Identity</span>&lt;<span class="org-type">long</span>&gt; <span class="org-variable-name">l</span>;
<span class="org-type">Identity</span>&lt;<span class="org-type">char</span>&gt; <span class="org-variable-name">c</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">twice</span> = [](<span class="org-keyword">auto</span> <span class="org-variable-name">z</span>) { <span class="org-keyword">return</span> 2 * z; };
<span class="org-keyword">auto</span> <span class="org-variable-name">i2</span>    = fmap(i, twice);
<span class="org-keyword">auto</span> <span class="org-variable-name">l2</span>    = fmap(l, twice);
<span class="org-keyword">auto</span> <span class="org-variable-name">c2</span>    = fmap(c, twice);

ASSERT_EQ(Identity{0}, i2);
ASSERT_EQ(Identity{0L}, l2);
ASSERT_EQ(Identity{<span class="org-string">'\0'</span>}, c2);

<span class="org-type">Identity</span>&lt;<span class="org-type">int</span>&gt;  <span class="org-variable-name">i3</span>(3);
<span class="org-type">Identity</span>&lt;<span class="org-type">long</span>&gt; <span class="org-variable-name">l3</span>(3);
<span class="org-type">Identity</span>&lt;<span class="org-type">char</span>&gt; <span class="org-variable-name">c3</span>(3);

<span class="org-keyword">auto</span> <span class="org-variable-name">i6</span> = fmap(i3, twice);
<span class="org-keyword">auto</span> <span class="org-variable-name">l6</span> = fmap(l3, twice);
<span class="org-keyword">auto</span> <span class="org-variable-name">c6</span> = fmap(c3, twice);

ASSERT_EQ(Identity{6}, i6);
ASSERT_EQ(Identity{<span class="org-constant">6</span><span class="org-keyword">L</span>}, l6);
ASSERT_EQ(Identity{<span class="org-string">'\6'</span>}, c6);

</pre>
</div>

<p> And the one argument form, where the only difference is we can use the fmapped lambda on all of the Identity instances: </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-type">Identity</span>&lt;<span class="org-type">int</span>&gt;  <span class="org-variable-name">i</span>;
<span class="org-type">Identity</span>&lt;<span class="org-type">long</span>&gt; <span class="org-variable-name">l</span>;
<span class="org-type">Identity</span>&lt;<span class="org-type">char</span>&gt; <span class="org-variable-name">c</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">twice</span>     = [](<span class="org-keyword">auto</span> <span class="org-variable-name">i</span>) { <span class="org-keyword">return</span> 2 * i; };
<span class="org-keyword">auto</span> <span class="org-variable-name">fmapTwice</span> = fmap(twice);

<span class="org-keyword">auto</span> <span class="org-variable-name">i2</span> = fmapTwice(i);
<span class="org-keyword">auto</span> <span class="org-variable-name">l2</span> = fmapTwice(l);
<span class="org-keyword">auto</span> <span class="org-variable-name">c2</span> = fmapTwice(c);

ASSERT_EQ(Identity{0}, i2);
ASSERT_EQ(Identity{0L}, l2);
ASSERT_EQ(Identity{<span class="org-string">'\0'</span>}, c2);

<span class="org-type">Identity</span>&lt;<span class="org-type">int</span>&gt;  <span class="org-variable-name">i3</span>(3);
<span class="org-type">Identity</span>&lt;<span class="org-type">long</span>&gt; <span class="org-variable-name">l3</span>(3);
<span class="org-type">Identity</span>&lt;<span class="org-type">char</span>&gt; <span class="org-variable-name">c3</span>(3);

<span class="org-keyword">auto</span> <span class="org-variable-name">i6</span> = fmapTwice(i3);
<span class="org-keyword">auto</span> <span class="org-variable-name">l6</span> = fmapTwice(l3);
<span class="org-keyword">auto</span> <span class="org-variable-name">c6</span> = fmapTwice(c3);

ASSERT_EQ(Identity{6}, i6);
ASSERT_EQ(Identity{<span class="org-constant">6</span><span class="org-keyword">L</span>}, l6);
ASSERT_EQ(Identity{<span class="org-string">'\6'</span>}, c6);


</pre>
</div>

<p> Fmap, and the Functor laws, gives a way of applying chains of functions to a Functor object and know that the application will behave sensibly. The equivalent STL algorithm is <code class="src src-C++"><span class="org-constant">std</span>::transform</code>, however that requires that there be iterators for the Functor, which means it can not be used for Functors like std::optional. If it were, then we could write code like </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-constant">std</span>::<span class="org-type">optional</span>&lt;<span class="org-type">int</span>&gt; <span class="org-function-name">mult</span>(<span class="org-constant">std</span>::<span class="org-type">optional</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">o1</span>, <span class="org-constant">std</span>::<span class="org-type">optional</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">o2</span>)
{
    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">a</span> : o1)
    {
        <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">b</span> : o2)
        {
            <span class="org-keyword">return</span> a*b;
        }
    }
    <span class="org-keyword">return</span> {};
}
</pre>
</div>

<p> The core function (a * b) is also something that fmap can't deal with directly. Fmap deals with functions of one argument, and this has two. It's <code class="src src-Haskell">int -&gt; int -&gt; int</code>, not <code class="src src-Haskell">int -&gt; int</code>. That's what Applicative is about. </p>
</div>
</div>

<div id="outline-container-orgf384ac4" class="outline-2">
<h3 id="orgf384ac4">Applicative and <code>ap</code>
</h3>
<div class="outline-text-2" id="text-orgf384ac4">
<p> Applicative is a little unnatural in C++. It arises via partial application, which functional languages usually have a direct syntax for, while in C++ we have at best lambda capture, and at worst <code>std::bind</code>, or the late, and unlamented, <code>std::bind1st</code>. The idea, though, is that you can treat a function like (*), multiply, with the type <code class="src src-Haskell">int -&gt; int -&gt; int</code> as a function that takes an int and returns a function with type <code class="src src-Haskell">int -&gt; int</code>. And it is useful to be able to do this with Functors. </p>

<p> Applicative introduces two operators in Haskell, one is an infix version of fmap, and the other is new, and exists to deal with chaining multi-argument functions. </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-Haskell" id="nil">(&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
(&lt;*&gt;) :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</pre>
</div>

<p> Infix notation, putting the operation in the middle of the arguments, can improve readability and ergonomics. It's one of the reasons the Uniform Function Call Syntax proposal gets traction. It's useful and natural to be able to say things in noun verb order, and is one of the attactions of member functions in the first place. There are libraries, such as Hana, that provide mechanisms to be able to infix funtions with syntax like <code class="src src-C++"> <span class="org-type">f</span> &lt;fmap&gt; <span class="org-variable-name">x</span></code>, which would translate to <code class="src src-C++">fmap(f, x)</code>. Note this doesn't match the argument order of the fmap I've used so far. The ergonomics of C++ dictate that functions that might take lambdas put that argument last, unless there is a compelling reason otherwise. API design work is hard. </p>

<p> The new function (&lt;*&gt;), also known as <code>ap</code>, takes a function wrapped in a Functor and applies it to an object wrapped in the Functor, and returns the result wrapped in the Functor. That function usually comes from fmaping, so you will see a chain of &lt;$&gt;&lt;*&gt;&lt;*&gt;… providing arguments to the function. For Identity this will just be calling the function with the contents. Often with the <code>pure</code> function as part of it, which is the other piece that Applicative introduces, with a terribly misleading name. The <code>pure</code> function takes a value and lifts it into the Functor in the most natural way possible. For container-like Applicatives, that is putting a single value into the container. </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-Haskell" id="nil">pure :: Applicative f =&gt; a -&gt; f a
</pre>
</div>

<p> Pure is also known as <code>return</code> for Monad, and also known as <code>unit</code>. All of these are somewhat misleading names. For C++ I tend to prefer <code>make</code>. This is generally a constructor, but we want to disambiguate constructor calls with control parameters. That is, we want to be sure we're calling the constructor of std::vector that makes a std::vector&lt;size_t&gt; that has one element, not a std::vector&lt;unsigned long&gt; that has size_t elements, all zero. In the case of the identity monad, make is pretty simple to implement. </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-type">Identity</span>&lt;<span class="org-type">T</span>&gt; <span class="org-function-name">make</span>(<span class="org-type">T</span> <span class="org-variable-name">t</span>) {
    <span class="org-keyword">return</span> <span class="org-type">Identity</span>&lt;<span class="org-type">T</span>&gt;{t};
}

</pre>
</div>

<p> If I wanted a more fully general make that handled other Applicative generic types, it would be a bit more complicated. If I want something like: </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C+" id="nil">    Identity&lt;int&gt;           i  = make&lt;Identity&gt;(1);
    Identity&lt;Identity&lt;int&gt;&gt; ii = make&lt;Identity&gt;(i);
</pre>
</div>
<p> where I can parameterize the make function on the template type parameter, it's a bit more complicated, because we can't partially specialize a function, and we want to be able to on the Value type of the Identity template. The standard trick is to delegate to a class template that is partially specialized. The base template looks like </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-keyword">template</span> &lt;<span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span>&gt; <span class="org-keyword">typename</span> <span class="org-type">Ap</span>, <span class="org-keyword">typename</span> <span class="org-type">Value</span>&gt;
<span class="org-keyword">struct</span> <span class="org-type">Applicative</span> {
    <span class="org-type">Ap</span>&lt;<span class="org-type">Value</span>&gt; <span class="org-function-name">make</span>(<span class="org-type">Value</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">v</span>);
    <span class="org-type">Ap</span>&lt;<span class="org-type">Value</span>&gt; <span class="org-function-name">make</span>(<span class="org-type">Value</span>&amp;&amp; <span class="org-variable-name">v</span>);
};
</pre>
</div>

<p> specialized as </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Value</span>&gt;
<span class="org-keyword">struct</span> <span class="org-type">Applicative</span>&lt;Identity, <span class="org-type">Value</span>&gt; {
    <span class="org-keyword">typedef</span> <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">decay</span>&lt;<span class="org-type">Value</span>&gt;::<span class="org-type">type</span> <span class="org-type">V</span>;
    <span class="org-type">Identity</span>&lt;<span class="org-type">V</span>&gt; <span class="org-variable-name">make</span>(V <span class="org-keyword">const</span>&amp; v) { <span class="org-keyword">return</span> <span class="org-type">Identity</span>&lt;<span class="org-type">V</span>&gt;{v}; }
    <span class="org-type">Identity</span>&lt;<span class="org-type">V</span>&gt; <span class="org-variable-name">make</span>(V&amp;&amp; v) { <span class="org-keyword">return</span> <span class="org-type">Identity</span>&lt;<span class="org-type">V</span>&gt;{v}; }
};
</pre>
</div>
<p> so that a <code>make</code> function looks like </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-keyword">template</span> &lt;<span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span>&gt; <span class="org-keyword">typename</span> <span class="org-type">Ap</span>, <span class="org-keyword">typename</span> <span class="org-type">Value</span>&gt;
<span class="org-type">Ap</span>&lt;<span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">decay</span>&lt;<span class="org-type">Value</span>&gt;::<span class="org-type">type</span>&gt; <span class="org-function-name">make</span>(<span class="org-type">Value</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">v</span>) {
    <span class="org-type">Applicative</span>&lt;<span class="org-type">Ap</span>, <span class="org-type">Value</span>&gt; <span class="org-variable-name">a</span>;
    <span class="org-keyword">return</span> a.make(v);
}

</pre>
</div>

<p> The base Applicative type allows writing generic code against different Applicative types. We'll come back to that in a bit. </p>

<p> The <code>ap</code> function, takes a function lifted into the applicative and a value lifted into the applicative, and invokes the function on the value. For Identity, this is just function invocation. For other Applicatives it can be more complicated, but it is always some variation on calling functions. Since there's no way of getting a value out of the Identity, <code>ap</code> needs to be a friend or member. </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">Identity</span> {
<span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    <span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Func</span>, <span class="org-keyword">typename</span> <span class="org-type">U</span>&gt;
    <span class="org-keyword">friend</span> <span class="org-keyword">auto</span> <span class="org-function-name">ap</span>(<span class="org-type">Identity</span>&lt;<span class="org-type">Func</span>&gt; <span class="org-keyword">const</span>&amp; <span class="org-variable-name">f</span>, <span class="org-type">Identity</span>&lt;<span class="org-type">U</span>&gt; <span class="org-variable-name">t</span>)
        -&gt; <span class="org-type">Identity</span>&lt;<span class="org-constant">std</span>::<span class="org-type">invoke_result_t</span>&lt;<span class="org-type">Func</span>, <span class="org-type">U</span>&gt;&gt;;
<span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
};

<span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Func</span>, <span class="org-keyword">typename</span> <span class="org-type">U</span>&gt;
<span class="org-keyword">auto</span> <span class="org-function-name">ap</span>(<span class="org-type">Identity</span>&lt;<span class="org-type">Func</span>&gt; <span class="org-keyword">const</span>&amp; <span class="org-variable-name">f</span>, <span class="org-type">Identity</span>&lt;<span class="org-type">U</span>&gt; <span class="org-variable-name">t</span>)
    -&gt; <span class="org-type">Identity</span>&lt;<span class="org-constant">std</span>::<span class="org-type">invoke_result_t</span>&lt;<span class="org-type">Func</span>, <span class="org-type">U</span>&gt;&gt; {
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::invoke(f.t_, t.t_);
}

</pre>
</div>

<p> A function wrapped in an applicative context shows up when you partially apply a function to an applicative. That is if you had a function like add </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-keyword">auto</span> <span class="org-function-name">add</span>(<span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span>) -&gt; <span class="org-type">int</span> {<span class="org-keyword">return</span> a + b;}
</pre>
</div>
<p> which takes two ints and returns an int, and you bind the first argument, returning a function from int to int </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil"><span class="org-keyword">auto</span> <span class="org-variable-name">bind_add</span> = [](<span class="org-type">int</span> <span class="org-variable-name">a</span>) {<span class="org-keyword">return</span> [a](<span class="org-type">int</span> <span class="org-variable-name">b</span>){<span class="org-keyword">return</span> add(a, b);};};
</pre>
</div>
<p> so instead of a function (int, int) -&gt; int, we have a function (int) -&gt; (int -&gt; int) and we fmap that function, where fmap takes a function (a -&gt; b) and gives you a function (a -&gt; F&lt;b&gt;), so the fmap gives you a function a function (int -&gt; F&lt;(int -&gt; int)&gt;). And then that function is something we can use for <code>ap</code> </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil">    <span class="org-type">Identity</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">i3</span>(3);
    <span class="org-keyword">auto</span> <span class="org-variable-name">partial</span> = fmap(i3, bind_add);
    <span class="org-comment-delimiter">// </span><span class="org-comment">partial is Identity&lt;int -&gt; int&gt; (roughly)</span>
    <span class="org-type">Identity</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">i4</span>(4);
    <span class="org-type">Identity</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">k</span> = ap(partial, i4);
    ASSERT_EQ(Identity&lt;<span class="org-type">int</span>&gt;(7), k);
</pre>
</div>

<p> In Haskell, where partial application comes built into the syntax of the language, this is all much more natural. The expressive power comes in cases where <code>ap</code> is more than just simple function application, as it is for the Identity applicative. Applicatives like Maybe or Expected can short circuit evaluation, for example. For multivalued functions, like List, the eventual result is the cartesian product of all the parameters, in a list. </p>

<p> Another way of looking at <code>ap</code> involves the <code>curry</code> conversion of a multiparameter function, named after Haskell Curry. A <code>curry</code> converts a function from something called like <code>f(a,b,c)</code> to something called like <code>f(a)(b)(c)</code>, where each call returns a function taking a single parameter, an the final result is the same. </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil">    <span class="org-keyword">auto</span> <span class="org-variable-name">curry1</span> = [](<span class="org-keyword">auto</span> <span class="org-variable-name">func</span>) {
        <span class="org-keyword">return</span> [func](<span class="org-type">int</span> <span class="org-variable-name">a</span>) {
            <span class="org-keyword">return</span> [func, a](<span class="org-type">int</span> <span class="org-variable-name">b</span>) {
                <span class="org-keyword">return</span> func(a, b);
            };
        };
    };
    <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = curry1(three);
    <span class="org-keyword">auto</span> <span class="org-variable-name">h</span> = g(3);
    ASSERT_EQ(7, h(4));
</pre>
</div>
<p> Here <code>curry1</code> unrolls a <code>func(int, int) -&gt; int</code> into a function that takes an int and returns a function taking an int returning an int. It's a straightforward generalization of <code>bind_add</code> from above. We can tale the curried function g, fmap it over an Identity&lt;int&gt; and then apply that partially bound function to another Identity&lt;int&gt;, as so: </p>

<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-C++" id="nil">    <span class="org-type">Identity</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">id3</span>(3);
    <span class="org-type">Identity</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">id4</span>(4);
    <span class="org-keyword">auto</span> <span class="org-variable-name">partial2</span> = fmap(id3, g);
    <span class="org-type">Identity</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">id7</span> = ap(partial2, id4);
    ASSERT_EQ(Identity&lt;<span class="org-type">int</span>&gt;(7), id7);

</pre>
</div>
</div>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2017/06/28/why-stdbind-cant-be-formally-deprecated/" class="u-url">Why std::bind can't be (formally) deprecated</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2017/06/28/why-stdbind-cant-be-formally-deprecated/" rel="bookmark">
            <time class="published dt-published" datetime="2017-06-28T00:00:00-04:00" itemprop="datePublished" title="2017-06-28 00:00">2017-06-28 00:00</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <div id="outline-container-org8869472" class="outline-2">
<h3 id="org8869472">Yes: std::bind should be replaced by lambda</h3>
<div class="outline-text-2" id="text-org8869472">
 For almost all cases, <code>std::bind</code> should be replaced by a lambda expression. It's idiomatic, and results in better code. There is almost no reason post C++11 to use <code>std::bind</code>. 

 Doing so is quite straightforward, capture each bind argument by value in the lambda capture list, and provide auto parameters for each of the placeholders, then call the bound callable using <code>std::invoke()</code>. That will handle the cases of member function pointers, as well as regular functions. Now, this is how to do it mechanically, if you were doing this as part of a manual refactoring, the lambda can be made even clearer. 

<div class="org-src-container">
<pre class="src src-c++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;functional&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">f</span>(<span class="org-type">int</span> <span class="org-variable-name">n1</span>, <span class="org-type">int</span> <span class="org-variable-name">n2</span>, <span class="org-type">int</span> <span class="org-variable-name">n3</span>) {
  <span class="org-constant">std</span>::cout &lt;&lt; n1 &lt;&lt; <span class="org-string">' '</span> &lt;&lt; n2 &lt;&lt; <span class="org-string">' '</span> &lt;&lt; n3 &lt;&lt; <span class="org-string">'\n'</span>;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">placeholders</span>;
  <span class="org-type">int</span> <span class="org-variable-name">n</span> = 5;
  <span class="org-keyword">auto</span> <span class="org-variable-name">f1</span> = <span class="org-constant">std</span>::bind(f, 2, n, _1);
  f1(10); <span class="org-comment-delimiter">// </span><span class="org-comment">calls f(2, 5, 10);</span>

  <span class="org-keyword">auto</span> <span class="org-variable-name">l1</span> = [ p1 = 2, p2 = n ](<span class="org-keyword">auto</span> <span class="org-variable-name">_1</span>) { <span class="org-keyword">return</span> <span class="org-constant">std</span>::invoke(f, p1, p2, _1); };
  l1(10);

  <span class="org-comment-delimiter">// </span><span class="org-comment">idiomatically</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">l1a</span> = [=](<span class="org-keyword">auto</span> <span class="org-variable-name">_1</span>){<span class="org-keyword">return</span> f(2, n, _1);};
  l1a(10);

  <span class="org-keyword">auto</span> <span class="org-variable-name">f2</span> = <span class="org-constant">std</span>::bind(f, 2, <span class="org-constant">std</span>::cref(n), _1);
  <span class="org-keyword">auto</span> <span class="org-variable-name">l2</span> = [ p1 = 2, p2 = <span class="org-constant">std</span>::cref(n) ](<span class="org-keyword">auto</span> <span class="org-variable-name">_1</span>) {
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::invoke(f, p1, p2, _1);
  };
  <span class="org-comment-delimiter">// </span><span class="org-comment">or</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">l2a</span> = [ p1 = 2, &amp;p2 = n ](<span class="org-keyword">auto</span> <span class="org-variable-name">_1</span>) {
      <span class="org-keyword">return</span> <span class="org-constant">std</span>::invoke(f, p1, p2, _1);
  };
  <span class="org-comment-delimiter">// </span><span class="org-comment">more idiomatically</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">l2b</span> = [&amp;](<span class="org-keyword">auto</span> <span class="org-variable-name">_1</span>){f(2, n, _1);};

  n = 7;
  f2(10); <span class="org-comment-delimiter">// </span><span class="org-comment">calls f(2, 7, 10);</span>

  l2(10);
  l2a(10);
  l2b(10);
}
</pre>
</div>


 Which results in: 

<pre class="example">
2 5 10
2 5 10
2 5 10
2 7 10
2 7 10
2 7 10
2 7 10

</pre>
</div>
</div>

<div id="outline-container-org783d5d0" class="outline-2">
<h3 id="org783d5d0">No: std::bind provides one thing lambda doesn't</h3>
<div class="outline-text-2" id="text-org783d5d0">
 The expression <code>std::bind</code> evaluates flattens <code>std::bind</code> sub-expressions, and passes the same placeholder parameters down. A nested bind is evaluated with the given parameters, and the result is passed in to the outer bind. So you can have a bind that does something like <code>g( _1, f(_1))</code>, and when you call it with a parameter, that same value will be passed to both g and f. The function g will receive <code>f(_1)</code> as its second parameter. 

 Now, you could rewrite the whole thing as a lambda, but <code>auto</code> potentially makes this a little more difficult. The result of <code>std::bind</code> is an unutterable type. They weren't supposed to be naked. However, <code>auto</code> means the expression could be broken down into parts, meaning that the translation from a <code>std::bind</code> expression to a lambda expression is potentially not mechanical. Or, the bind could be part of a template, where the subexpression is a template parameter, which is likely working by accident, rather than design. 

 In any case, <code>std::bind</code> does not treat its arguments uniformly. It treats a bind expression distinctly differently. At the time, it made some sense. But it makes reasoning about bind expressions difficult. 

 Don't do this. But it is why formally deprecating <code>std::bind</code> is difficult. They can be replaced, but not purely mechanically. 

 There isn't a simple translation that works, unlike converting from <code>std::auto_ptr</code> to <code>std::unique_ptr</code>, or putting a space after a string where it now looks like a conversion. And, <code>std::bind</code> isn't broken. It's sub-optimal because of the complicated machinery to support all of the flexibility, where a lambda allows the compiler to do much better. Also, since the type isn't utterable, it often ends up in a std::function, which erases the type, removing optimization options. 
</div>
</div>

<div id="outline-container-org74c813b" class="outline-2">
<h3 id="org74c813b">Example of fail code</h3>
<div class="outline-text-2" id="text-org74c813b">
<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;functional&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">void</span> <span class="org-function-name">f</span>(<span class="org-type">int</span> <span class="org-variable-name">n1</span>, <span class="org-type">int</span> <span class="org-variable-name">n2</span>, <span class="org-type">int</span> <span class="org-variable-name">n3</span>)
{
    <span class="org-constant">std</span>::cout &lt;&lt; n1 &lt;&lt; <span class="org-string">' '</span> &lt;&lt; n2 &lt;&lt; <span class="org-string">' '</span> &lt;&lt; n3 &lt;&lt; <span class="org-string">'\n'</span>;
}

<span class="org-type">int</span> <span class="org-function-name">g</span>(<span class="org-type">int</span> <span class="org-variable-name">n1</span>) { <span class="org-keyword">return</span> n1; }

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
    <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">placeholders</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">g1</span> = <span class="org-constant">std</span>::bind(g, _1);
    <span class="org-keyword">auto</span> <span class="org-variable-name">f2</span> = <span class="org-constant">std</span>::bind(f, _1, g1, 4);
    f2(10); <span class="org-comment-delimiter">// </span><span class="org-comment">calls f(10, g(10), 4);</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">THIS DOES NOT WORK</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">auto l2 = [p1 = g1, p2 = 4](auto _1) {std::invoke(f, _1, p1, p2);};</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">l2(10);</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">The bind translation needs to be composed:</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">l1</span> = [](<span class="org-keyword">auto</span> <span class="org-variable-name">_1</span>){<span class="org-keyword">return</span> g(_1);};
    <span class="org-keyword">auto</span> <span class="org-variable-name">l2</span> = [p1 = l1, p2 = 4](<span class="org-keyword">auto</span> <span class="org-variable-name">_1</span>){f(_1, p1(_1), p2); };
    <span class="org-comment-delimiter">// </span><span class="org-comment">idiomatically</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">l2a</span> = [](<span class="org-keyword">auto</span> <span class="org-variable-name">_1</span>) { <span class="org-keyword">return</span> f(_1, g(_1), 4);};
    l2(10);
    l2a(10);
}


</pre>
</div>

<pre class="example">
10 10 4
10 10 4
10 10 4

</pre>
</div>
</div>

<div id="outline-container-orgbe0a9a3" class="outline-2">
<h3 id="orgbe0a9a3">
<span class="todo TODO">TODO</span> </h3>
<div class="outline-text-2" id="text-orgbe0a9a3">
 If someone can figure out a fixit recommendation that could be safely applied, transforming the old bind to a lambda, then <code>std::bind</code> could be deprecated in C++Next, and removed as soon as C++(Next++). But that right now is non-trivial in some cases. 
</div>
</div>

<div id="outline-container-orgd9aeff5" class="outline-2">
<h3 id="orgd9aeff5">Updates:</h3>
<div class="outline-text-2" id="text-orgd9aeff5">
<ul class="org-ul">
<li>Fix incorrect statement about type-erasure in std::bind. I was thinking std::function</li>
<li>Add more idiomatic transliterations of the std::bind lambdas</li>
</ul>
</div>
</div>

<div id="outline-container-org1041288" class="outline-2">
<h3 id="org1041288">Building and running the examples</h3>
<div class="outline-text-2" id="text-org1041288">
</div>
<div id="outline-container-orgc36032d" class="outline-3">
<h4 id="orgc36032d">Makefile</h4>
<div class="outline-text-3" id="text-orgc36032d">
<div class="org-src-container">
<pre class="src src-makefile"><span class="org-makefile-targets">clean</span>:
    <span class="org-type">-</span><span class="org-makefile-shell">rm example1</span>
    <span class="org-type">-</span><span class="org-makefile-shell">rm example2</span>

<span class="org-makefile-targets">example1</span>: example1.cpp
    clang++ --std=c++1z example1.cpp -o example1

<span class="org-makefile-targets">example2</span>: example2.cpp
    clang++ --std=c++1z example2.cpp -o example2

<span class="org-makefile-targets">example3</span>: example3.cpp
    clang++ --std=c++1z example3.cpp -o example3 2&gt;&amp;1

<span class="org-makefile-targets">all</span>: example1 example2

</pre>
</div>
</div>
</div>


<div id="outline-container-org9675a68" class="outline-3">
<h4 id="org9675a68">Build</h4>
<div class="outline-text-3" id="text-org9675a68">
<pre class="example">
rm example1
rm example2
clang++ --std=c++1z example1.cpp -o example1
clang++ --std=c++1z example2.cpp -o example2

</pre>
</div>
</div>
<div id="outline-container-org92834af" class="outline-3">
<h4 id="org92834af">Original source</h4>
<div class="outline-text-3" id="text-org92834af">
 Original document is available on <a href="https://raw.githubusercontent.com/steve-downey/what-comes-to-mind/master/why-bind-cant-be-deprecated.org">Github</a> 
</div>
</div>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2017/01/08/accessing-the-elements-of-a-tuple-as-variant/" class="u-url">Accessing the elements of a tuple as variant</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2017/01/08/accessing-the-elements-of-a-tuple-as-variant/" rel="bookmark">
            <time class="published dt-published" datetime="2017-01-08T00:00:00-05:00" itemprop="datePublished" title="2017-01-08 00:00">2017-01-08 00:00</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>A further digression, because it turns out I want to be able to permute a tuple at run time. That means treating the element of a tuple generically. And I can just barely do this, for some tuples, in c++17. 

 So a slight digression into ADTs. Which in this case means Algebraic Data Types, not Abstract Data Types. But just algebra. No calculus, or differentiation, of data types. Not today. 

</p>
<div id="outline-container-org2cdd471" class="outline-2">
<h3 id="org2cdd471">
<span class="section-number-2">1</span> Tuple is Product, Variant is Sum</h3>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orge3984c5" class="outline-3">
<h4 id="orge3984c5">
<span class="section-number-3">1.1</span> Products</h4>
<div class="outline-text-3" id="text-1-1">
 In algebra, we usually start out with addition. It's simpler. But for types, multiplication, or product, is in many ways much more natural. Your basic struct, record, etc is a natural product of types. A type is some kind of collection of things. And I'm being a bit vague here because this is right in the area where set seems like a good idea, and then we get into sets of sets, sets that might contain themselves, and barbers who shave all the people who don't shave themselves. There is rigour, but I don't really want to have to go there. 

 But, if we start with the idea that a type is a collection of things, and that we don't look to closely at the infinities, we are not going to be terribly wrong. So a type is a way of describing if a thing is in or out of the collection. 

 Now, I could pretend we don't know what a struct is. Start with pairs, where there are no names of the components of the struct, and build that up. But we all have a notion of struct. It's an ordered collection of types. The instances of the struct are all of the elements of each type contained in the struct, matched up with all of the other elements of all the other types in the struct. Known as the Cartesion product. So if you have a type A, and a type B, the collection of things in struct {A a; B b;} is the cross of As and Bs. That is {{a<sub>1</sub>, b<sub>1</sub>}, {a<sub>1</sub>, b<sub>2</sub>}, {a<sub>1</sub>, b<sub>3</sub>}, … , {a<sub>2</sub>, b<sub>1</sub>}, {a<sub>2</sub>, b<sub>2</sub>}, … {a<sub>n</sub>, b<sub>1</sub>}, … {a<sub>n</sub>, b<sub>m</sub>}} is all of the elements that are part of the type struct {A a; B b;}. The cardinality of {A, B} is the product of the cardinalities of A and B. 

 Structs are very natural in C++, but hard to deal with generically, so there's a type that does it all for you, std::tuple. Getting at the parts of the tuple is a little more difficult that with a struct. You have to say std::get&lt;0&gt;(tuple), or std::get&lt;int&gt;(tuple). And the second might not even compile, if the tuple has more than one int. But you get tools for composing and decomposing tuples at compile time. And std::tuple lets you put pretty much any C++ type into the tuple, only restricting you when you try to, e.g. move a tuple that has an element that can't be moved. 

 There should also be a type that acts as a unit for the product, the equivalent of 1 for multiplication. The empty tuple can work as a unit. It contains any of the list of no types. This implies that all empty tuples are equivalent, so its cardinality is 1. There can be only one. The product of a type with the empty tuple is entirely equivalent to the the type itself. There are no additional elements in the type, and you can convert back and forth between them. They are isomorphic, having the same shape. 

 Isomorphisms are important in talking about types, because most of the time we can't actually distinguish between isomorphic types, at least for proving things. The phrase "up to isomorphism" shows up a lot. To be isomorphic means that we can write a transformation $LATEX X$ from type A to type B, and a reverse transformation $LATEX Y$ from type B to type A, such that $latex Y(X(a)) == a$ for all a, and that for any function from a<sub>1</sub> to a<sub>2</sub>, there is an equivalent function from b<sub>1</sub> to b<sub>2</sub>. We could mechanically replace instances of a with the appropriate b and add calls to X and Y without changing the behavior of a program. 
</div>
</div>

<div id="outline-container-orgab373e6" class="outline-3">
<h4 id="orgab373e6">
<span class="section-number-3">1.2</span> Sums</h4>
<div class="outline-text-3" id="text-1-2">
 The other basic algebraic type is the sum type. The corresponding primitive in C++ is a union, with one difference. In most type systems, the sum type automatically remembers which of the allowed types is in it. A union doesn't, so the standard technique is to embed the union in a struct that carries a tag saying which type in the union was most recently written, and can be read from. I'll be ignoring type-punning schemes allowing a read of a different type than was written. 

 So a Sum type of type A and type B is the union of all of the things in A and all of the things in B. {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, … , a<sub>n</sub>, b<sub>1</sub>, b<sub>2</sub>, … , b<sub>m</sub>}. The cardinality of is the sum of the cardinalities of A and B. 

 The unit type of the sum is equivalent to zero. The empty sum type, although a valid type, has no elements in the type. It's like the empty set. It's often known as Void, where the unit for product is often called Unit. It may also be known as Bottom, where that is a computation that never completes. Since there are no elements of the type Void, it can't be instantiated. And a product of Void and any other type is equivalent to Void. The c++ type <code>void</code> is related, but not exactly the same, because it also represents an empty argument list, a function that returns, but does not return any value (a subroutine), and is also functions as the universal pointer. 

 C++17 recently standardized a sum type to go with the long standardized std::tuple, std::variant. Std::variant remembers which of the alternative types was last set. It is almost never empty, only so if a write into one of the alternatives threw an exception. It is not allowed to hold <code>void</code>, references, arrays, or to contain no types. This is a bit unfortunate, because except for <code>void</code> std::tuple can do all of those things. 

 There were several competing models for what std::variant should be, with various tradeoffs being made. It was always clear that std::tuple had to be able to represent everything a struct can, and in fact there are now language features to destructure a struct into a tuple. There is no equivalent model for sum types. Union can't hold anything but trivial types because there is no mechanism to track what to do on destruction, since there is no built-in mechanism to determine what the union was last written as. 

 One of the popular models for variant rises out of database-like interfaces. Even though databases are internally strongly typed, SQL queries are not. And the model of sending text over and getting some kind of response back makes it difficult to expose that to a host language. Particularly when the database schema may change, the query still be perfectly valid, but no longer return the same types. However, since we do know there is a relatively short list of permitted types in the database, a variant that allows just those types and the ability to query what type was returned can be quite useful, and not terribly hard to implement. There are JSON parsers taking similar approaches, only with the addition that a JSON type may have JSON objects contained in them recursively, and those have to be outside the object somehow, or the size of the object is unbounded. 

 From the implementors point of view, supporting pointers and arrays is a huge amout of extra work. Not allowing an array to decay to a pointer is quite difficult. References have issues when treated generically. Not to mention that references have decidely odd semantics in the differences between construction and assignment. And the degenerate case of an empty variant was also difficult. If that needs to be represented, the type std::monostate has been introduced, which is a type designed to have exactly one item in it, so that all instances of std::monostate are identical. This is also the same as the unit type for product types. It's not an accident that it's represented in Haskell as (), which is the empty tuple. All empty lists are equivalent. It could have been <code>std::tuple&lt;&gt;</code>, but no one in the room happened to think of that. 
</div>
</div>
</div>

<div id="outline-container-org7c3ced4" class="outline-2">
<h3 id="org7c3ced4">
<span class="section-number-2">2</span> Tuple is a Heterogenous Container, what is the iterator?</h3>
<div class="outline-text-2" id="text-2">
 The C++ standard says "tuples are heterogeneous, fixed-size collections of values" - [tuple.general]. Collections generally have iterator types associated with them, but that's a bit of a challenge since the iterator model in C++ assumes that for a collection, the type of *(Collection&lt;T&gt;::iterator) is T. But if the collection isn't on T, but on Types…, you doesn't quite work to say *(Collection&lt;typename… Types&gt;) is of type …Types. You need something to hold that. But in many cases, std::variant can work. It doesn't quiet work, since we'd really need a variant of references to the elements of the tuple, so that they could be written to. However, for many purposes we can come close. For the case I was looking at, making copies is perfectly fine. What I'm looking for is something roughly with the signature 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span>... Types
<span class="org-keyword">auto</span> getElement(<span class="org-type">size_t</span> <span class="org-variable-name">i</span>, <span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;Types...&gt; <span class="org-variable-name">tuple</span>) -&gt; <span class="org-constant">std</span>::<span class="org-type">variant</span>&lt;Types...&gt;;
</pre>
</div>

 That is, something that will get me the i<sub>th</sub> element of a tuple, as a variant with the same typelist as the tuple, with the index determined at runtime. All of the normal accessors are compile time. So need to do something that will make the compile time information available at runtime. 

 Start with something I do know how to do, idiomatically printing a tuple. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Func</span>, <span class="org-keyword">typename</span> <span class="org-type">Tuple</span>, <span class="org-constant">std</span>::<span class="org-type">size_t</span>... <span class="org-variable-name">I</span>&gt;
<span class="org-type">void</span> <span class="org-function-name">tuple_for_each_impl</span>(<span class="org-type">Tuple</span>&amp;&amp; <span class="org-variable-name">tuple</span>, <span class="org-type">Func</span>&amp;&amp; <span class="org-variable-name">f</span>, <span class="org-constant">std</span>::<span class="org-type">index_sequence</span>&lt;I...&gt;)
{
    <span class="org-keyword">auto</span> <span class="org-variable-name">swallow</span> = {0,
                    (<span class="org-constant">std</span>::forward&lt;<span class="org-type">Func</span>&gt;(f)(
                        I, <span class="org-constant">std</span>::get&lt;I&gt;(<span class="org-constant">std</span>::forward&lt;<span class="org-type">Tuple</span>&gt;(tuple))))...};
    (<span class="org-type">void</span>)swallow;
}

<span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Func</span>, <span class="org-keyword">typename</span>... Args&gt;
<span class="org-type">void</span> <span class="org-function-name">tuple_for_each</span>(<span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;Args...&gt; <span class="org-keyword">const</span>&amp; <span class="org-variable-name">tuple</span>, <span class="org-variable-name">Func</span>&amp;&amp; f)
{
    tuple_for_each_impl(tuple, f, <span class="org-constant">std</span>::<span class="org-type">index_sequence_for</span>&lt;Args...&gt;{});
}

<span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span>... Args&gt;
<span class="org-type">void</span> <span class="org-function-name">print</span>(<span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;Args...&gt; <span class="org-keyword">const</span>&amp; <span class="org-variable-name">tuple</span>)
{
    <span class="org-keyword">auto</span> <span class="org-variable-name">printer</span> = [&amp;os](<span class="org-keyword">auto</span> <span class="org-variable-name">i</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">el</span>) {
        os &lt;&lt; (i == 0 ? <span class="org-string">""</span> : <span class="org-string">", "</span>) &lt;&lt; el;
        <span class="org-keyword">return</span> 0;
    };
    <span class="org-keyword">return</span> tuple_for_each(tuple, printer);
}
</pre>
</div>

 Actually, a bit more complicated than the totally standard idiom, since it factors out the printer into a application across the tuple, but it's not much more compilcated. The tuple_for_each constructs an index sequence based on the argument list, and delegates that to the impl, which uses it to apply the function to each element of the tuple. The _impl ought to be in a nested detail namespace, so as not to leak out. Swallow is the typical name for using an otherwise unnamed, and uninteresting, type to apply something to each element of the tuple for a side-effect. The void cast is to make sure the variable is used, and is evaluated. 

 The next step is, instead of an application of a function for its side-effect, instead a mapping of the tuple, returning the transformed tuple. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Func</span>, <span class="org-keyword">typename</span> <span class="org-type">Tuple</span>, <span class="org-constant">std</span>::<span class="org-type">size_t</span>... <span class="org-variable-name">I</span>&gt;
<span class="org-keyword">auto</span> <span class="org-function-name">tuple_transform_impl</span>(<span class="org-type">Tuple</span>&amp;&amp; <span class="org-variable-name">tuple</span>, <span class="org-type">Func</span>&amp;&amp; <span class="org-variable-name">f</span>, <span class="org-constant">std</span>::<span class="org-type">index_sequence</span>&lt;I...&gt;)
{
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_tuple(
        <span class="org-constant">std</span>::forward&lt;<span class="org-type">Func</span>&gt;(f)(<span class="org-constant">std</span>::get&lt;I&gt;(<span class="org-constant">std</span>::forward&lt;<span class="org-type">Tuple</span>&gt;(tuple)))...);
}

<span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Func</span>, <span class="org-keyword">typename</span>... Args&gt;
<span class="org-keyword">auto</span> <span class="org-function-name">tuple_transform</span>(<span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;Args...&gt;&amp;&amp; <span class="org-variable-name">tuple</span>, <span class="org-variable-name">Func</span>&amp;&amp; f)
{
    <span class="org-keyword">return</span> tuple_transform_impl(tuple, f, <span class="org-constant">std</span>::<span class="org-type">index_sequence_for</span>&lt;Args...&gt;{});
}

<span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">Func</span>, <span class="org-keyword">typename</span>... Args&gt;
<span class="org-keyword">auto</span> <span class="org-function-name">tuple_transform</span>(<span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;Args...&gt; <span class="org-keyword">const</span>&amp; <span class="org-variable-name">tuple</span>, <span class="org-variable-name">Func</span>&amp;&amp; f)
{
    <span class="org-keyword">return</span> tuple_transform_impl(tuple, f, <span class="org-constant">std</span>::<span class="org-type">index_sequence_for</span>&lt;Args...&gt;{});
}
</pre>
</div>

 Because the std::tuple is not a template parameter, I have to supply a const&amp; and a forwarding-reference form to cover both cases. And I'm ignoring volatile quals. The _impl function uses forwarding-reference parameters, which will decay or forward properly using std::forward. Using it is straightforward. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;<span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">long</span>&gt; <span class="org-variable-name">t</span> = <span class="org-constant">std</span>::make_tuple(1, 2.3, 1l);
<span class="org-keyword">auto</span> <span class="org-variable-name">transform</span> = <span class="org-constant">tupleutil</span>::tuple_transform(t,
                                            [](<span class="org-keyword">auto</span> <span class="org-variable-name">i</span>) { <span class="org-keyword">return</span> i + 1; });

EXPECT_EQ(3.3, <span class="org-constant">std</span>::get&lt;1&gt;(transform));

<span class="org-keyword">auto</span> <span class="org-variable-name">t2</span> = <span class="org-constant">tupleutil</span>::tuple_transform(<span class="org-constant">std</span>::make_tuple(4, 5.0),
                                     [](<span class="org-keyword">auto</span> <span class="org-variable-name">i</span>) { <span class="org-keyword">return</span> i + 1; });
EXPECT_EQ(6, <span class="org-constant">std</span>::get&lt;1&gt;(t2));
</pre>
</div>

 So, for functions over all the types in a tuple, tuple is a Functor. That is, we can apply the function to all elements in the tuple, and it's just like making a tuple out of applying the functions to elements before making the tuple. If this sounds like a trivial distinction, you are mostly right. Almost all container-ish things are Functors, and a few non-containerish things are also. Plus Functor sounds more impressive. 

 The transform also suggests a way of solving the problem I was originally looking at. An array of the elements of the tuple each as a variant will let me permute them with std tools. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span>... Args, <span class="org-constant">std</span>::<span class="org-type">size_t</span>... <span class="org-variable-name">I</span>&gt;
<span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">array</span>&lt;<span class="org-constant">std</span>::<span class="org-type">variant</span>&lt;Args...&gt;, <span class="org-keyword">sizeof</span>...(Args)&gt;
<span class="org-function-name">tuple_to_array_impl</span>(<span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;Args...&gt; <span class="org-keyword">const</span>&amp; <span class="org-variable-name">tuple</span>,
                    <span class="org-constant">std</span>::<span class="org-type">index_sequence</span>&lt;I...&gt;)
{
    <span class="org-keyword">using</span> <span class="org-type">V</span> = <span class="org-constant">std</span>::<span class="org-type">variant</span>&lt;Args...&gt;;
    <span class="org-constant">std</span>::<span class="org-type">array</span>&lt;<span class="org-type">V</span>, <span class="org-keyword">sizeof</span>...(Args)&gt; <span class="org-variable-name">array</span> = {
        {<span class="org-function-name">V</span>(<span class="org-constant">std</span>::<span class="org-type">in_place_index_t</span>&lt;I&gt;{}, <span class="org-constant">std</span>::get&lt;I&gt;(<span class="org-variable-name">tuple</span>))...}};
    <span class="org-keyword">return</span> array;
}

<span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span>... Args&gt;
<span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">array</span>&lt;<span class="org-constant">std</span>::<span class="org-type">variant</span>&lt;Args...&gt;, <span class="org-keyword">sizeof</span>...(Args)&gt;
<span class="org-function-name">tuple_to_array</span>(<span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;Args...&gt; <span class="org-keyword">const</span>&amp; <span class="org-variable-name">tuple</span>)

{
    <span class="org-keyword">return</span> tuple_to_array_impl(tuple, <span class="org-constant">std</span>::<span class="org-type">index_sequence_for</span>&lt;Args...&gt;{});
}
</pre>
</div>

 And that can be used something like: 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-function-name">TEST</span>(TupleTest, to_array)
{
    <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;<span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">long</span>&gt; <span class="org-variable-name">t</span> = <span class="org-constant">std</span>::make_tuple(1, 2.3, 1l);
    <span class="org-keyword">auto</span> <span class="org-variable-name">arr</span> = <span class="org-constant">tupleutil</span>::tuple_to_array(t);
    <span class="org-type">int</span>  <span class="org-variable-name">i</span>   = <span class="org-constant">std</span>::get&lt;<span class="org-type">int</span>&gt;(arr[0]);
    EXPECT_EQ(1, i);
}

<span class="org-function-name">TEST</span>(TupleTest, to_array_repeated)
{
    <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-variable-name">t</span> = <span class="org-constant">std</span>::make_tuple(1, 2, 3);
    <span class="org-keyword">auto</span> <span class="org-variable-name">arr</span> = <span class="org-constant">tupleutil</span>::tuple_to_array(t);
    <span class="org-type">int</span>  <span class="org-variable-name">i</span>   = <span class="org-constant">std</span>::get&lt;2&gt;(arr[2]);
    EXPECT_EQ(3, i);
}
</pre>
</div>

 The second test is there because I was about to write, "as you can see, we can tell the differece between variants holding the same type", except that wasn't true. The original version of to_ar 

<div class="org-src-container">
<pre class="src src-C++">    <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;<span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">long</span>&gt; <span class="org-variable-name">t</span> = <span class="org-constant">std</span>::make_tuple(1, 2.3, 1l);
    <span class="org-constant">std</span>::<span class="org-type">variant</span>&lt;<span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">long</span>&gt; <span class="org-variable-name">v0</span>{1};
    <span class="org-keyword">auto</span> <span class="org-variable-name">v</span> = <span class="org-constant">tupleutil</span>::get(0, t);
    EXPECT_EQ(v0, v);
</pre>
</div>
 ray didn't use the constructor form with std::in_place_index_t. The code I ended up with did, but not at this point. There's nothing like writing out what something is supposed to do to make you look and keep you honest. 

 So here, we're constructing an array of std::variant&lt;Args…&gt; and constructing each member with the argument pack expansion into the std::variant constructor using the I<sub>th</sub> index value to get that element of the tuple, and recording that we're constructing the i<sub>th</sub> alternative of the variant. The second test checks that. The 2nd element of the array must be the 2nd variant of the tuple, and can be retrieved only by std::get&lt;2&gt;(). 

 This would allow me to permutate the elements of a tuple, but I'm fairly close now to being able to writing a version that allows choice of the element at runtime, rather than at compile time. 

<div class="org-src-container">
<pre class="src src-C++">    <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;<span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">long</span>&gt; <span class="org-variable-name">t</span> = <span class="org-constant">std</span>::make_tuple(1, 2.3, 1l);
    <span class="org-constant">std</span>::<span class="org-type">variant</span>&lt;<span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">long</span>&gt; <span class="org-variable-name">v0</span>{1};
    <span class="org-keyword">auto</span> <span class="org-variable-name">v</span> = <span class="org-constant">tupleutil</span>::get(0, t);
    EXPECT_EQ(v0, v);
</pre>
</div>

 What I'm going to do is construct an array of the getters for the tuple, each of which will return the element wrapped in a variant. The signature of the array will be of function pointer type, because, quite conveniently, a non-capturing lambda can decay to a function pointer. 

 First getting the array of getters for the tuple 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">V</span>, <span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-type">size_t</span> <span class="org-variable-name">I</span>&gt; <span class="org-keyword">auto</span> <span class="org-function-name">get_getter</span>()
{
    <span class="org-keyword">return</span> [](<span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">t</span>) {
        <span class="org-keyword">return</span> V{<span class="org-constant">std</span>::<span class="org-type">in_place_index_t</span>&lt;I&gt;{}, <span class="org-constant">std</span>::get&lt;I&gt;(t)};
    };
}

<span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span>... Args, <span class="org-constant">std</span>::<span class="org-type">size_t</span>... <span class="org-variable-name">I</span>&gt;
<span class="org-keyword">auto</span> <span class="org-function-name">tuple_getters_impl</span>(<span class="org-constant">std</span>::<span class="org-type">index_sequence</span>&lt;I...&gt;)
{
    <span class="org-keyword">using</span> <span class="org-type">V</span> = <span class="org-constant">std</span>::<span class="org-type">variant</span>&lt;Args...&gt;;
    <span class="org-keyword">using</span> <span class="org-type">T</span> = <span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;Args...&gt;;
    <span class="org-keyword">using</span> <span class="org-type">F</span> = V (*)(<span class="org-type">T</span> <span class="org-keyword">const</span>&amp;);
    <span class="org-constant">std</span>::<span class="org-type">array</span>&lt;<span class="org-type">F</span>, <span class="org-keyword">sizeof</span>...(Args)&gt; <span class="org-variable-name">array</span>
        <span class="org-comment-delimiter">//        </span><span class="org-comment">= {{[](T const&amp; tuple){return V{std::get&lt;I&gt;(tuple)};}...}};</span>
        = {{get_getter&lt;<span class="org-type">V</span>, <span class="org-type">T</span>, I&gt;()...}};
    <span class="org-keyword">return</span> array;
}

<span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span>... Args&gt; <span class="org-keyword">auto</span> <span class="org-function-name">tuple_getters</span>(<span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;Args...&gt;)
{
    <span class="org-keyword">return</span> tuple_getters_impl&lt;Args...&gt;(<span class="org-constant">std</span>::<span class="org-type">index_sequence_for</span>&lt;Args...&gt;{});
}
</pre>
</div>

 So first a function that returns a function that constructs a variant around the value of what's returned from std::get&lt;I&gt;. Well, it could return anything that happens to have a constructor that takes a an in_place_index_t, take as the thing to be converted something that std::get&lt;I&gt; can extract from. This is actually a separate function because GCC was unhappy doing the template parameter pack expansion inline in the _impl function. Clang was happy with the expansion noted in the comment. I really have no idea who is wrong here, and the workaround was straight forward. The array is one of function pointers, which the returned lambdas can decay to. 

 Now the only remaining trick is to use this array as a table to dispatch to the appropriate getter for the tuple. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-keyword">auto</span> get = [](<span class="org-type">size_t</span> <span class="org-variable-name">i</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">t</span>) {
    <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-variable-name">tbl</span> = <span class="org-constant">tupleutil</span>::tuple_getters(t);
    <span class="org-keyword">return</span> tbl[i](t);
};
</pre>
</div>

 Get the array as a static, so we only need to computer it once, and simply return <code>tbl[i](t)</code> 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-function-name">TEST</span>(TupleTest, gettersStatic)
{
    <span class="org-keyword">constexpr</span> <span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;<span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">long</span>&gt; <span class="org-variable-name">t</span> = <span class="org-constant">std</span>::make_tuple(1, 2.3, 1l);
    <span class="org-constant">std</span>::<span class="org-type">variant</span>&lt;<span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">long</span>&gt; <span class="org-variable-name">v0</span>{1};
    <span class="org-keyword">auto</span> <span class="org-variable-name">v</span> = <span class="org-constant">tupleutil</span>::get(0, t);
    EXPECT_EQ(v0, v);

    <span class="org-type">int</span>  <span class="org-variable-name">i</span> = <span class="org-constant">std</span>::get&lt;0&gt;(v);
    EXPECT_EQ(1, i);

    <span class="org-keyword">auto</span> <span class="org-variable-name">v2</span> = <span class="org-constant">tupleutil</span>::get(1, t);

    EXPECT_EQ(1ul, v2.index());
    <span class="org-type">double</span> <span class="org-variable-name">d</span> = <span class="org-constant">std</span>::get&lt;<span class="org-type">double</span>&gt;(v2);

    EXPECT_EQ(2.3, d);

    <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> t2 = <span class="org-constant">std</span>::make_tuple(2.4, 1l);
    <span class="org-keyword">auto</span>           <span class="org-variable-name">v3</span> = <span class="org-constant">tupleutil</span>::get(0, t2);
    <span class="org-type">double</span>         <span class="org-variable-name">d2</span> = <span class="org-constant">std</span>::get&lt;<span class="org-type">double</span>&gt;(v3);

    EXPECT_EQ(2.4, d2);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd331339" class="outline-2">
<h3 id="orgd331339">
<span class="section-number-2">3</span> Source</h3>
<div class="outline-text-2" id="text-3">
 All source is available at <a href="https://github.com/steve-downey/tupleutil">TupleUtil</a> on GitHub, including org source for this post. 
</div>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2016/11/25/cross-compiling/" class="u-url">Cross Compiling</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2016/11/25/cross-compiling/" rel="bookmark">
            <time class="published dt-published" datetime="2016-11-25T00:00:00-05:00" itemprop="datePublished" title="2016-11-25 00:00">2016-11-25 00:00</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <div id="table-of-contents">
<h3>Table of Contents</h3>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/index.php/2016/11/25/cross-compiling/#orgd2b0594">1. Setting up Cross Compiling</a></li>
<li><a href="posts/index.php/2016/11/25/cross-compiling/#org0578f92">2. Sysroot</a></li>
<li><a href="posts/index.php/2016/11/25/cross-compiling/#org3ccfeaa">3. Static linking</a></li>
<li><a href="posts/index.php/2016/11/25/cross-compiling/#org34b5cfe">4. CMake</a></li>
<li><a href="posts/index.php/2016/11/25/cross-compiling/#org575bf77">5. Sources</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgd2b0594" class="outline-2">
<h3 id="orgd2b0594">
<span class="section-number-2">1</span> Setting up Cross Compiling</h3>
<div class="outline-text-2" id="text-1">
 In order to test out some of these multi-threaded tool properly, I really need to run them on a less strict platform than x86_64. X86_64 provides a lot of guarantees about sequential consistency and atomicity that hides problems that will happen on architectures that are not as strong, like power, sparc, and arm. Fortunately, one of the toys I have is a recent Raspberry Pi 3, which is based on a recent arm chip. Unfortunately, Raspbian, the normal linux distro for the Raspberry Pi is also based on a fairly old debian distro, with a fairly old compiler. Linaro is back porting their arm code genaration fixes to the old releases, but I'm more interested in the recent C++ language features. So I could attempt to compile GCC 6 on the RPi, or I can cross compile from my normal machine. I decided to cross compile, since if that worked, it would be considerably easier. It turnd out to be pretty straightfoward. 

<div class="org-src-container">
<pre class="src src-shell">sudo apt-get install g++-6-arm-linux-gnueabihf
</pre>
</div>

 This is mostly because I'm already doing software development on the box, so I didn't need any of the other parts of the compiler ecosystem, just the right c++ toolchain. The hardest part is determining the right one. There are a few flavors for arm development. The RPi is the gnu extended abi, with hardware float. The Ubuntu repositories only supply linux variants, which is sensible. Since that top level package ends up installing not just the compilers, but a libstdc++ and libc for arm-linux-gnueabihf, which need to know much more about the OS in order to interface with it. 

 This does lead to one snag, though. The versions of the libraries are not the ones available on the RPi. Which is a problem, since I want to use modern, or maybe even post-modern C++. There are two ways of dealing with this, and I've ended up using both. 
</div>
</div>

<div id="outline-container-org0578f92" class="outline-2">
<h3 id="org0578f92">
<span class="section-number-2">2</span> Sysroot</h3>
<div class="outline-text-2" id="text-2">
 When cross compiling, a sysroot is a system that looks just like the root file system of the target platform. It will have /lib, /usr/lib, etc, with the versions of the libraries that you want. You can either use a disk image, mounted somewhere convienent, or you can just mount the target computer's root filesystem somewhere convienent. If you do that, you'll have access to all of the libraries available, not just the minimal set typically available on a prepackaged sysroot. So that's what I did. 

<div class="org-src-container">
<pre class="src src-shell">sshfs sdowney@cobweb.local:/ /home/sdowney/mnt/rpi/ -o transform_symlinks -o allow_other
</pre>
</div>

 Cobweb is my Raspberry Pi box, and zeroconf makes the current ip address available as cobweb.local. I'm mounting that into ~/mnt/rpi, transforming symlinks so that they actually work, and allowing others to access the mounted fs. 

 With that I can specify the sysroot, and have the compiler look there for libraries: 

<div class="org-src-container">
<pre class="src src-shell">arm-linux-gnueabihf-g++-6 -v --sysroot ~/mnt/rpi/ -o hello hw.cpp
</pre>
</div>

 That spits out all of what the compiler driver invokes, and as a byproduct, a bunch of what is needed to set up cross compiling with other compilers, like clang. The key things to look for are the include directories called out by "#include &lt;…&gt; search starts here", and the LIBRARY_PATH variable that helps define what the linker does. I'll be pulling those out for the clang cross compile cmake toolchain file. 

<pre class="example">
Using built-in specs.
COLLECT_GCC=arm-linux-gnueabihf-g++-6
COLLECT_LTO_WRAPPER=/usr/lib/gcc-cross/arm-linux-gnueabihf/6/lto-wrapper
Target: arm-linux-gnueabihf
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 6.2.0-5ubuntu12' --with-bugurl=file:///usr/share/doc/gcc-6/README.Bugs --enable-languages=c,ada,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-6 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-6-armhf-cross/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-6-armhf-cross --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-6-armhf-cross --with-arch-directory=arm --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libgcj --enable-objc-gc --enable-multiarch --enable-multilib --disable-sjlj-exceptions --with-arch=armv7-a --with-fpu=vfpv3-d16 --with-float=hard --with-mode=thumb --disable-werror --enable-multilib --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=arm-linux-gnueabihf --program-prefix=arm-linux-gnueabihf- --includedir=/usr/arm-linux-gnueabihf/include
Thread model: posix
gcc version 6.2.0 20161005 (Ubuntu 6.2.0-5ubuntu12)
COLLECT_GCC_OPTIONS='-v' '-o' 'hello' '-shared-libgcc' '-march=armv7-a' '-mfloat-abi=hard' '-mfpu=vfpv3-d16' '-mthumb' '-mtls-dialect=gnu'
 /usr/lib/gcc-cross/arm-linux-gnueabihf/6/cc1plus -quiet -v -imultiarch arm-linux-gnueabihf -isysroot /home/sdowney/mnt/rpi/ -D_GNU_SOURCE hw.cpp -quiet -dumpbase hw.cpp -march=armv7-a -mfloat-abi=hard -mfpu=vfpv3-d16 -mthumb -mtls-dialect=gnu -auxbase hw -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccUwr5Jd.s
GNU C++14 (Ubuntu 6.2.0-5ubuntu12) version 6.2.0 20161005 (arm-linux-gnueabihf)
    compiled by GNU C version 6.2.0 20161005, GMP version 6.1.1, MPFR version 3.1.5, MPC version 1.0.3, isl version 0.15
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring nonexistent directory "/home/sdowney/mnt/rpi/usr/local/include/arm-linux-gnueabihf"
#include "..." search starts here:
#include &lt;...&gt; search starts here:
 /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/include/c++/6
 /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/include/c++/6/arm-linux-gnueabihf
 /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/include/c++/6/backward
 /usr/lib/gcc-cross/arm-linux-gnueabihf/6/include
 /usr/lib/gcc-cross/arm-linux-gnueabihf/6/include-fixed
 /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/include
 /home/sdowney/mnt/rpi/usr/include/arm-linux-gnueabihf
 /home/sdowney/mnt/rpi/usr/include
End of search list.
GNU C++14 (Ubuntu 6.2.0-5ubuntu12) version 6.2.0 20161005 (arm-linux-gnueabihf)
    compiled by GNU C version 6.2.0 20161005, GMP version 6.1.1, MPFR version 3.1.5, MPC version 1.0.3, isl version 0.15
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
Compiler executable checksum: 8867fa57a9cbba18ebd7880e42ca78ba
COLLECT_GCC_OPTIONS='-v' '-o' 'hello' '-shared-libgcc' '-march=armv7-a' '-mfloat-abi=hard' '-mfpu=vfpv3-d16' '-mthumb' '-mtls-dialect=gnu'
 /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/bin/as -v -march=armv7-a -mfloat-abi=hard -mfpu=vfpv3-d16 -meabi=5 -o /tmp/ccJH2IA5.o /tmp/ccUwr5Jd.s
GNU assembler version 2.27 (arm-linux-gnueabihf) using BFD version (GNU Binutils for Ubuntu) 2.27
COMPILER_PATH=/usr/lib/gcc-cross/arm-linux-gnueabihf/6/:/usr/lib/gcc-cross/arm-linux-gnueabihf/6/:/usr/lib/gcc-cross/arm-linux-gnueabihf/:/usr/lib/gcc-cross/arm-linux-gnueabihf/6/:/usr/lib/gcc-cross/arm-linux-gnueabihf/:/usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/bin/
LIBRARY_PATH=/usr/lib/gcc-cross/arm-linux-gnueabihf/6/:/usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/lib/../lib/:/home/sdowney/mnt/rpi/lib/arm-linux-gnueabihf/:/home/sdowney/mnt/rpi/lib/../lib/:/home/sdowney/mnt/rpi/usr/lib/arm-linux-gnueabihf/:/home/sdowney/mnt/rpi/usr/lib/../lib/:/usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/lib/:/home/sdowney/mnt/rpi/lib/:/home/sdowney/mnt/rpi/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'hello' '-shared-libgcc' '-march=armv7-a' '-mfloat-abi=hard' '-mfpu=vfpv3-d16' '-mthumb' '-mtls-dialect=gnu'
 /usr/lib/gcc-cross/arm-linux-gnueabihf/6/collect2 -plugin /usr/lib/gcc-cross/arm-linux-gnueabihf/6/liblto_plugin.so -plugin-opt=/usr/lib/gcc-cross/arm-linux-gnueabihf/6/lto-wrapper -plugin-opt=-fresolution=/tmp/cctgBCzX.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --sysroot=/home/sdowney/mnt/rpi/ --build-id --eh-frame-hdr -dynamic-linker /lib/ld-linux-armhf.so.3 -X --hash-style=gnu --as-needed -m armelf_linux_eabi -z relro -o hello /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/lib/../lib/crt1.o /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/lib/../lib/crti.o /usr/lib/gcc-cross/arm-linux-gnueabihf/6/crtbegin.o -L/usr/lib/gcc-cross/arm-linux-gnueabihf/6 -L/usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/lib/../lib -L/home/sdowney/mnt/rpi/lib/arm-linux-gnueabihf -L/home/sdowney/mnt/rpi/lib/../lib -L/home/sdowney/mnt/rpi/usr/lib/arm-linux-gnueabihf -L/home/sdowney/mnt/rpi/usr/lib/../lib -L/usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/lib -L/home/sdowney/mnt/rpi/lib -L/home/sdowney/mnt/rpi/usr/lib /tmp/ccJH2IA5.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc-cross/arm-linux-gnueabihf/6/crtend.o /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/lib/../lib/crtn.o
COLLECT_GCC_OPTIONS='-v' '-o' 'hello' '-shared-libgcc' '-march=armv7-a' '-mfloat-abi=hard' '-mfpu=vfpv3-d16' '-mthumb' '-mtls-dialect=gnu'
</pre>

 Now, note that the compiler will prefer the locally installed versions before using the ones in the sysroot. This is fine, until I need to install something. Then I'll get an error because the library on the RPi is too old. Particularly libstdc++. This works well for the non-core language libraries, though. Or at least ones that don't have C++ in their interface. Mixing C++ versions is a horrible minefield. The easiest way to deal with it is to avoid it. 
</div>
</div>

<div id="outline-container-org3ccfeaa" class="outline-2">
<h3 id="org3ccfeaa">
<span class="section-number-2">3</span> Static linking</h3>
<div class="outline-text-2" id="text-3">
 Recent versions of gcc allow libstdc++ to be linked statically. It increases the size of the resulting executable, but with less worries about deployment issues. 

<pre class="example">
-static-libstdc++
</pre>

 That will cause the compiler driver to direct the linker to prefer the static version of libstdc++, rather than the shared version. And I don't have to worry about deploying or upgrading the system libraries on the target box. 

 Note, this isn't really a supported deployment configuration. So any bugs are going to be my problem. 
</div>
</div>

<div id="outline-container-org34b5cfe" class="outline-2">
<h3 id="org34b5cfe">
<span class="section-number-2">4</span> CMake</h3>
<div class="outline-text-2" id="text-4">
 I've been using CMake to generate the build system, so I need to explain to it how to use the cross compiler instead of one for the host system. CMake has support for supplying definitions for these in <a href="https://cmake.org/cmake/help/v3.5/manual/cmake-toolchains.7.html">Toolchain</a> files. This is what I have so far 

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">SET</span>(CMAKE_SYSTEM_NAME Linux)
<span class="org-function-name">SET</span>(CMAKE_SYSTEM_VERSION 1)
<span class="org-function-name">SET</span>(CMAKE_SYSROOT $ENV{HOME}/mnt/rpi)

<span class="org-function-name">SET</span>(CMAKE_C_COMPILER arm-linux-gnueabihf-gcc)
<span class="org-function-name">SET</span>(CMAKE_CXX_COMPILER arm-linux-gnueabihf-g++)

<span class="org-function-name">SET</span>(CMAKE_FIND_ROOT_PATH $ENV{HOME}/mnt/rpi)
<span class="org-function-name">SET</span>(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
<span class="org-function-name">SET</span>(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
<span class="org-function-name">SET</span>(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

<span class="org-function-name">SET</span>(CMAKE_CXX_FLAGS <span class="org-string">"-static-libgcc -static-libstdc++"</span> CACHE STRING <span class="org-string">"CXX_FLAGS"</span> FORCE)

<span class="org-function-name">SET</span>( THREADS_PTHREAD_ARG
     <span class="org-string">"0"</span>
     CACHE STRING <span class="org-string">"Result from TRY_RUN"</span> FORCE)
</pre>
</div>

 That, in addition to setting the compiler to use, forces a few CMake options that are otherwise problems. The first is setting the static link flag for libstdc++. The second is overriding the search for pthreads, because trying to run programs built with a cross compiler doesn't work very well. This lies and forces the option. 

 Used like so 

<div class="org-src-container">
<pre class="src src-shell">cmake  -D <span class="org-variable-name">CMAKE_TOOLCHAIN_FILE</span>=~/src/toolchain/pi.cmake -DCMAKE_BUILD_TYPE=Release ..
</pre>
</div>

 A toolchain file for clang is a little more complicated, because it doesn't really understand the gcc multilib layout, so it needs to be told where all the include and lib directories are for the target system, for both the C and C++ compiler. 

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">SET</span>(CMAKE_SYSTEM_NAME Linux)
<span class="org-function-name">SET</span>(CMAKE_SYSTEM_VERSION 1)
<span class="org-function-name">SET</span>(CMAKE_SYSROOT $ENV{HOME}/mnt/rpi)

<span class="org-function-name">set</span>(triple arm-linux-gnueabihf)

<span class="org-function-name">set</span>(CMAKE_C_COMPILER clang)
<span class="org-function-name">set</span>(CMAKE_C_COMPILER_TARGET ${<span class="org-variable-name">triple</span>})
<span class="org-function-name">set</span>(CMAKE_CXX_COMPILER clang++)
<span class="org-function-name">set</span>(CMAKE_CXX_COMPILER_TARGET ${<span class="org-variable-name">triple</span>})

<span class="org-function-name">SET</span>(CMAKE_FIND_ROOT_PATH $ENV{HOME}/mnt/rpi)
<span class="org-function-name">SET</span>(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
<span class="org-function-name">SET</span>(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
<span class="org-function-name">SET</span>(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

<span class="org-function-name">SET</span>(CMAKE_CXX_FLAGS <span class="org-string">"\</span>
<span class="org-string"> -isystem /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/include/c++/6 \</span>
<span class="org-string"> -isystem /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/include/c++/6/arm-linux-gnueabihf \</span>
<span class="org-string"> -isystem /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/include/c++/6/backward \</span>
<span class="org-string"> -isystem /usr/lib/gcc-cross/arm-linux-gnueabihf/6/include \</span>
<span class="org-string"> -isystem /usr/lib/gcc-cross/arm-linux-gnueabihf/6/include-fixed \</span>
<span class="org-string"> -isystem /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/include"</span>
  CACHE STRING <span class="org-string">"CXX_FLAGS"</span> FORCE)

<span class="org-function-name">SET</span>(CMAKE_C_FLAGS <span class="org-string">"\</span>
<span class="org-string"> -isystem /usr/lib/gcc-cross/arm-linux-gnueabihf/6/include \</span>
<span class="org-string"> -isystem /usr/lib/gcc-cross/arm-linux-gnueabihf/6/include-fixed \</span>
<span class="org-string"> -isystem /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/include"</span>
  CACHE STRING <span class="org-string">"C_FLAGS"</span> FORCE)

<span class="org-function-name">SET</span>(CMAKE_EXE_LINKER_FLAGS <span class="org-string">"\</span>
<span class="org-string"> -L /usr/lib/gcc-cross/arm-linux-gnueabihf/6 \</span>
<span class="org-string"> -L /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/lib/../lib \</span>
<span class="org-string"> -L /usr/lib/gcc-cross/arm-linux-gnueabihf/6/../../../../arm-linux-gnueabihf/lib \</span>
<span class="org-string"> -static-libgcc -static-libstdc++"</span>
  CACHE STRING <span class="org-string">"LINKER FLAGS"</span> FORCE)

<span class="org-function-name">SET</span>( THREADS_PTHREAD_ARG
     <span class="org-string">"0"</span>
     CACHE STRING <span class="org-string">"Result from TRY_RUN"</span> FORCE)
</pre>
</div>
</div>
</div>

<div id="outline-container-org575bf77" class="outline-2">
<h3 id="org575bf77">
<span class="section-number-2">5</span> Sources</h3>
<div class="outline-text-2" id="text-5">
 Toolchain files are on <a href="https://github.com/steve-downey/toolchain">Github</a> next to the <a href="https://github.com/steve-downey/spingate">spingate</a> sources, that now includes the org file that is the source for this entry, <a href="https://github.com/steve-downey/spingate/blob/master/crosscompile.org">crosscompile.org</a>. 
</div>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2016/11/16/batch-running-functions-under-a-spingate/" class="u-url">batch: running functions under a spingate</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2016/11/16/batch-running-functions-under-a-spingate/" rel="bookmark">
            <time class="published dt-published" datetime="2016-11-16T00:00:00-05:00" itemprop="datePublished" title="2016-11-16 00:00">2016-11-16 00:00</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <div id="outline-container-orga656deb" class="outline-2">
<h3 id="orga656deb">
<span class="section-number-2">1</span> A batch of tasks to run</h3>
<div class="outline-text-2" id="text-1">
 This adds a rather simple component to spingate orchestrating a batch of tasks to be run, gated by the spingate. The tasks are added one at a time, a thread is created for the task, and the thread waits on the spingate to open before calling the task. 

 Or at least that's how it started. Task was originally a std::function&lt;void()&gt;, which is essentially the interface of the thread pool I use. I realized, however, that I don't actually need to restrict the interface quite that much. Thread takes a much wider range of things to run, and I can do the same thing. I have to forward the supplied callable and arguments into the lambda that the thread is running. 

 The key bit of code is 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">Function</span>, <span class="org-keyword">class</span>... Args&gt;
<span class="org-type">void</span> <span class="org-constant">Batch</span>::<span class="org-function-name">add</span>(<span class="org-type">Function</span>&amp;&amp; <span class="org-variable-name">f</span>, <span class="org-type">Args</span>&amp;&amp;... args) {
    workers_.emplace_back([ <span class="org-keyword">this</span>, f = <span class="org-constant">std</span>::forward&lt;<span class="org-type">Function</span>&gt;(f), args... ]() {
            gate_.wait();
            f(args...);
        });
}
</pre>
</div>

 There's a lot of line noise in there, and it really looked simpler when it was just taking a std::function&lt;void()&gt;, but it's not terrible. We take an object of type Function and a parameter pack of type Args by forwarding reference. That gets captured by the lambda, where we forward the function to the lambda, and capture the parameter pack. Inside the lambda we call the function with the pack, f(args). It's probable that I should have used std::invoke there, which handles some of the more interesting cases of calling a thing with arguments. But this was sufficient unto the day. The captured this allows access to the gate_ variable the we're waiting on. The workers_ are a vector of threads that we'll later run run through and join() on, after open()ing the gate_. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">Batch</span>::<span class="org-function-name">run</span>() {
    gate_.open();
    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span>&amp; <span class="org-variable-name">thr</span> : workers_) {
        thr.join();
    }
}
</pre>
</div>


 That's really all there is to Batch. It's a middle connective glue component. Does one thing, and tries to do it obviously well. That is important since I'm trying to build up test infrastructure, and testing the test infrastrucure is a hard problem. 

 I have reorganized the code repo in order to do some light testing, though. 
</div>
</div>

<div id="outline-container-org135204d" class="outline-2">
<h3 id="org135204d">
<span class="section-number-2">2</span> GTest</h3>
<div class="outline-text-2" id="text-2">
 I've pushed things about in the source repo, moving the code into a library directory, which means I can link it into the existing mains, as well as into new gtests. In the CMake system, I've conditioned building tests on the existence of the googletest project being available as a subdirectory. I use enough different compilers and build options that trying to use a system build of gtest just doesn't work. The best, and recommended, choice, is to build googletest as part of your project. That way any ABI impacting subtlety, like using a different C++ standard library, is take care of automatically. The bit of cmake magic is in the top level CMakeLists.txt : 

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-comment"># A directory to find Google Test sources.</span>
<span class="org-keyword">if</span> (EXISTS <span class="org-string">"${</span><span class="org-variable-name">CMAKE_CURRENT_SOURCE_DIR</span><span class="org-string">}/googletest/CMakeLists.txt"</span>)
  <span class="org-function-name">add_subdirectory</span>(googletest EXCLUDE_FROM_ALL)
  <span class="org-function-name">add_subdirectory</span>(tests)
<span class="org-keyword">else</span>()
  <span class="org-function-name">message</span>(<span class="org-string">"GTEST Not Found at ${</span><span class="org-variable-name">CMAKE_CURRENT_SOURCE_DIR</span><span class="org-string">}/googletest/CMakeLists.txt"</span>)
<span class="org-keyword">endif</span>()
</pre>
</div>
 This looks for googletest to be available, and if it is, add it to the project, and my tests subdirectory, otherwise issue a message. I prefer this to attempting to fix up the missing gtest automatically. That always seems to cause me problems, such as when I'm operating disconnected, on a train, like right now. 

 The tests I have are pretty simple, not much more than primitive breathing tests. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-function-name">TEST_F</span>(BatchTest, run1Test)
{
    <span class="org-type">Batch</span> <span class="org-variable-name">batch</span>;
    batch.add([<span class="org-keyword">this</span>](){incrementCalled();});

    EXPECT_EQ(0u, called);

    batch.run();

    EXPECT_EQ(1u, called);
}
</pre>
</div>

 or, to make sure that passing arguments worked 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-function-name">TEST_F</span>(BatchTest, runArgTest)
{
    <span class="org-type">Batch</span> <span class="org-variable-name">batch</span>;
    <span class="org-type">int</span> <span class="org-variable-name">i</span> = 0;
    batch.add([&amp;i](<span class="org-type">int</span> <span class="org-variable-name">k</span>){ i = k;}, 1);

    EXPECT_EQ(0, i);

    batch.run();

    EXPECT_EQ(1, i);
}
</pre>
</div>

 I don't actually expect to find runtime errors with these tests. They exercise ths component just enough that I'm not generating compile errors in expected use cases. Template code can be tricky that way. Templates that aren't instantiated can have horrible errors, but the compiler is willing to let them pass, if they mostly parse. 

 SFINAE may not be your friend. 
</div>
</div>

<div id="outline-container-orgf36cf22" class="outline-2">
<h3 id="orgf36cf22">
<span class="section-number-2">3</span> Clang builds with current libc++</h3>
<div class="outline-text-2" id="text-3">
 Building clang and libc++ locally is getting easier and easier. Using that is still a bit difficult. But there are some reasons to do so. One is just being able to cross check your code for sanity. I won't reproduce building clang and libc++ here. It's really at this point just checking out the repos in the right places and running cmake with something like: 

<div class="org-src-container">
<pre class="src src-shell">cmake  -DCMAKE_INSTALL_PREFIX=~/install/llvm-master/ -DLLVM_ENABLE_LIBCXX=yes  -DCMAKE_BUILD_TYPE=Release   ../llvm/
</pre>
</div>

 Using that, at least from within cmake, is more complicated. Cmake has a strong bias towards using the system compiler. It also has a distinct problem with repeating builds. 

 NEVER edit your CMakeCache.txt. You can't do anything with it. All the paths are hard coded. Always start over. Either keep the command line around, or create a cmake initial cache file, which isn't the same thing at all as the CMakeCache.txt file. 

 Right now, I'm cargo-culting around code in my cmake files that checks if I've defined an LLVM_ROOT, and if I have supply the flags to ignore all the system files, and use the ones from the installed LLVM_ROOT, including some rpath fixup. There might be some way to convince cmake to do it, but there's also only so much I will fight my metabuild system. 

<div class="org-src-container">
<pre class="src src-cmake">  <span class="org-keyword">if</span>(LLVM_ROOT)
    <span class="org-function-name">message</span>(STATUS <span class="org-string">"LLVM Root: ${</span><span class="org-variable-name">LLVM_ROOT</span><span class="org-string">}"</span>)
    <span class="org-function-name">set</span>(CMAKE_CXX_FLAGS <span class="org-string">"${</span><span class="org-variable-name">CMAKE_CXX_FLAGS</span><span class="org-string">} -nostdinc++ -isystem ${</span><span class="org-variable-name">LLVM_ROOT</span><span class="org-string">}/include/c++/v1"</span>)
    <span class="org-function-name">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="org-string">"${</span><span class="org-variable-name">CMAKE_EXE_LINKER_FLAGS</span><span class="org-string">} -L ${</span><span class="org-variable-name">LLVM_ROOT</span><span class="org-string">}/lib -l c++ -l c++abi"</span>)
    <span class="org-function-name">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="org-string">"${</span><span class="org-variable-name">CMAKE_EXE_LINKER_FLAGS</span><span class="org-string">} -Wl,-rpath,${</span><span class="org-variable-name">LLVM_ROOT</span><span class="org-string">}/lib"</span>)
  <span class="org-keyword">else</span>()
</pre>
</div>

 I only check for that if the compiler I've chosen is a clang compiler, and it's not normally part of my environment. 
</div>
</div>

<div id="outline-container-org2ba138e" class="outline-2">
<h3 id="org2ba138e">
<span class="section-number-2">4</span> Direction</h3>
<div class="outline-text-2" id="text-4">
 Overall, what I want out of this library is to be able to stress test some nominally mt-safe code, and check that the conditions that I think hold are true. It's heavily influenced by jcstress, but, because this is C+++, it will be rendered quite differently. 

 For what I'm considering, look at <a href="https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/">Close Encounters of The Java Memory Model Kind</a> 

 I want to be able to specify a state, with operations that mutate and observe the state. I want to be able to collect those observations in a deterministic way, which may require cooperation from the observers. I want to be able to collect the observations and report how many times each set of observations was obtained. 

 Something like: 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">State</span> {
    <span class="org-type">int</span> <span class="org-variable-name">x_</span>;
    <span class="org-type">int</span> <span class="org-variable-name">y_</span>;

  <span class="org-keyword">public</span>:
    <span class="org-keyword">typedef</span> <span class="org-constant">std</span>::<span class="org-type">tuple</span>&lt;<span class="org-type">int</span>, <span class="org-type">int</span>, <span class="org-type">int</span>, <span class="org-type">int</span>&gt; <span class="org-type">Result</span>;
    <span class="org-function-name">State</span>() : x_(0), y_(0) {}
    <span class="org-type">void</span> <span class="org-function-name">writer1</span>() {
        y_ = 1;
        x_ = 1;
    }
    <span class="org-type">void</span> <span class="org-function-name">reader1</span>(<span class="org-type">Result</span>&amp; <span class="org-variable-name">read</span>) {
        <span class="org-constant">std</span>::get&lt;0&gt;(read) = x_;
        <span class="org-constant">std</span>::get&lt;1&gt;(read) = y_;
    }
    <span class="org-type">void</span> <span class="org-function-name">reader2</span>(<span class="org-type">Result</span>&amp; <span class="org-variable-name">read</span>) {
        <span class="org-constant">std</span>::get&lt;2&gt;(read) = x_;
        <span class="org-constant">std</span>::get&lt;3&gt;(read) = y_;
    }
};
</pre>
</div>

 Running the writers and readers over different threads and observing the possible results. On some architectures, reader1 and reader2 can see entirely different orders, even though y_ will happen before x_, you might see x_ written and not y_. 

 What I'd eventually like to be able to do is say things like, "This function will only be evaluated once", and have some evidence to back that up. 

 So the next step is something that will take a State and schedule all of the actions with appropriate parameters in a Batch, and produce the overall Result. Then something that will do that many many times, accumulating all of the results. And since this isn't java, so we don't have reflection techniques, the State class is going to have to cooperate a bit. The Result typedef is one way. It will also have to produce all of the actions that need to be batched, in some heterogenous form that I can then run. 
</div>
</div>

<div id="outline-container-orga889604" class="outline-2">
<h3 id="orga889604">
<span class="section-number-2">5</span> Source Code</h3>
<div class="outline-text-2" id="text-5">
 Exported from an org-mode doc, batch.org, which is available, with all of the source on github at <a href="https://github.com/steve-downey/spingate">SpinGate</a>. 
</div>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2016/10/29/spingate/" class="u-url">spingate</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2016/10/29/spingate/" rel="bookmark">
            <time class="published dt-published" datetime="2016-10-29T00:00:00-04:00" itemprop="datePublished" title="2016-10-29 00:00">2016-10-29 00:00</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <div id="outline-container-org3e3344d" class="outline-2">
<h3 id="org3e3344d">
<span class="section-number-2">1</span> Building a simple spin gate in C++</h3>
<div class="outline-text-2" id="text-1">
 This is a very simplified latch which allows several threads to block and busywait until they are released to begin work in parallel. I'm using this to do some multi-thread stress testing, where I want to maximize the overlapping work in order to check for suprising non-deterministic behavior. There's no count associated with the gate, nor is it reuseable. All we need is the one bit of information, weather the gate is open or closed. 

 The simplest atomic boolean is the std::atomic_flag. It's guaranteed by standard to be lock free. Unfortunately, to provide that guarantee, it provides no way to do an atomic read or write to the flag, just a clear, and a set and return prior value. This isn't rich enough for multiple threads to wait, although it is enough to implement a spinlock. 

 std::atomic&lt;bool&gt; isn't guaranteed to be lock free, but in practice, any architecture I'm interested has at least 32bit aligned atomics that are lock free. Older hardware, such as ARMv5, SparcV8, and 80386 are missing cmpxchg, so loads are generally implemented with a lock in order to maintain the guarantees if there were a simultaneous load and exchange. See, for example, <a href="http://llvm.org/docs/Atomics.html">LLVM Atomic Instructions and Concurrency Guide</a>. Modern ARM, x86, Sparc, and Power chips are fine. 

 When the spin gate is constructed, we'll mark the gate as closed. Threads will then wait on the flag, spinning until the gate is opened. For this we use Release-Acquire ordering between the open and wait. This will ensure any stores done before the gate is opened will be visible to the thread waiting. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">spingate.h                                                       -*-C++-*-</span>
<span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> INCLUDED_SPINGATE
<span class="org-preprocessor">#define</span> <span class="org-variable-name">INCLUDED_SPINGATE</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;atomic&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;thread&gt;</span>

<span class="org-keyword">class</span> <span class="org-type">SpinGate</span>
{
    <span class="org-constant">std</span>::<span class="org-type">atomic_bool</span> <span class="org-variable-name">flag_</span>;

  <span class="org-keyword">public</span>:
    <span class="org-function-name">SpinGate</span>();
    <span class="org-type">void</span> <span class="org-function-name">wait</span>();
    <span class="org-type">void</span> <span class="org-function-name">open</span>();
};

<span class="org-keyword">inline</span>
<span class="org-constant">SpinGate</span>::<span class="org-function-name">SpinGate</span>() {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Close the gate</span>
    flag_.store(<span class="org-constant">true</span>, <span class="org-constant">std</span>::memory_order_release);
}

<span class="org-keyword">inline</span>
<span class="org-type">void</span> <span class="org-constant">SpinGate</span>::<span class="org-function-name">wait</span>() {
    <span class="org-keyword">while</span> (flag_.load(<span class="org-constant">std</span>::memory_order_acquire))
        ; <span class="org-comment-delimiter">// </span><span class="org-comment">spin</span>
}

<span class="org-keyword">inline</span>
<span class="org-type">void</span> <span class="org-constant">SpinGate</span>::<span class="org-function-name">open</span>() {
    flag_.store(<span class="org-constant">false</span>, <span class="org-constant">std</span>::memory_order_release);
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::yield();
}


<span class="org-preprocessor">#endif</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">"spingate.h"</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Test that header is complete by including</span>
</pre>
</div>


 Using a SpinGate is fairly straightfoward. Create an instance of SpinGate and wait() on it in each of the worker threads. Once all of the threads are created, open the gate to let them run. In this example, I sleep for one second in order to check that none of the worker threads get past the gate before it is opened. 

 The synchronization is on the SpingGate's std::atomic_bool, flag_. The flag_ is set to true in the constructor, with release memory ordering. The function wait() spins on loading the flag_ with acquire memory ordering, until open() is called, which sets the flag_ to false with release semantics. The other threads that were spinning may now proceed. The release-acquires ordering ensures that happens-before writes by the thread setting up the work and calling open will be read by the threads that were spin waiting. 
</div>

<div id="outline-container-org632ad29" class="outline-3">
<h4 id="org632ad29">
<span class="section-number-3">1.1</span> Update:</h4>
<div class="outline-text-3" id="text-1-1">
 I've added a yield() call after the open, hinting that the thread opening the gate may be rescheduled and allow the other threads to run. On the system I'm testing on, it doesn't seem to make a difference, but it does seem like the right thing to do, and it does not seem to hurt. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">"spingate.h"</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;chrono&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;thread&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>


<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">std</span>::thread&gt; <span class="org-variable-name">workers</span>;
    <span class="org-type">SpinGate</span> <span class="org-variable-name">gate</span>;
    <span class="org-keyword">using</span> <span class="org-type">time_point</span> = <span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-type">time_point</span>&lt;<span class="org-constant">std</span>::<span class="org-constant">chrono</span>::high_resolution_clock&gt;;
    <span class="org-type">time_point</span> <span class="org-variable-name">t1</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">threadCount</span> = <span class="org-constant">std</span>::<span class="org-constant">thread</span>::hardware_concurrency();
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">time_point</span>&gt; <span class="org-variable-name">times</span>;
    times.resize(threadCount);

    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">n</span> = 0; n &lt; threadCount; ++n) {
        workers.emplace_back([&amp;gate, t1, &amp;times, n]{
                gate.wait();
                <span class="org-type">time_point</span> <span class="org-variable-name">t2</span> = <span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-constant">high_resolution_clock</span>::now();
                times[n] = t2;
            });
    }

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Open the gate in 1 second: "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for(1s);
    t1 = <span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-constant">high_resolution_clock</span>::now();
    gate.open();

    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span>&amp; <span class="org-variable-name">thr</span> : workers) {
        thr.join();
    }

    <span class="org-type">int</span> <span class="org-variable-name">threadNum</span> = 0;
    <span class="org-keyword">for</span> (<span class="org-keyword">auto</span>&amp; <span class="org-variable-name">time</span>: times) {
        <span class="org-keyword">auto</span> <span class="org-variable-name">diff</span> = <span class="org-constant">std</span>::<span class="org-constant">chrono</span>::duration_cast&lt;<span class="org-constant">std</span>::<span class="org-constant">chrono</span>::nanoseconds&gt;(time - t1);
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Thread "</span> &lt;&lt; threadNum++ &lt;&lt; <span class="org-string">" waited "</span> &lt;&lt; diff.count() &lt;&lt; <span class="org-string">"ns\n"</span>;
    }
}
</pre>
</div>

 I'd originally had the body of the threads just spitting out that they were running on std::cout, and the lack of execution before the gate, plus the overlapping output, being evidence of the gate working. That looked like: 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-keyword">for</span> (<span class="org-constant">std</span>::<span class="org-type">size_t</span> <span class="org-variable-name">n</span> = 0; n &lt; <span class="org-constant">std</span>::<span class="org-constant">thread</span>::hardware_concurrency(); ++n) {
    workers.emplace_back([&amp;gate, n]{
            gate.wait();
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Output from gated thread "</span> &lt;&lt; n &lt;&lt; <span class="org-constant">std</span>::endl;
        });
}
</pre>
</div>

 The gate is captured in the thread lambda by reference, the thread number by value, and when run, overlapping gibberish is printed to the console as soon as open() is called. 

 But then I became curious about how long the spin actually lasted. Particularly since the guarantees for atomics with release-acquire semantics, or really even sequentially consistent, are about once a change is visible, that changes before are also visible. It's really a function of the underlying hardware how fast the change is visible, and what are the costs of making the happened-before writes available. I'd already observed better overlapping execution using the gate, as opposed to just letting the threads run, so for my initial purposes of making contention more likely, I was satisfied. Visibility, on my lightly loaded system, seems to be in the range of a few hundred to a couple thousand nanoseconds, which is fairly good. 

 Checking how long it took to start let me do two thing. First, play with the new-ish chrono library. Second, check that the release-acquire sync is working the way I expect. The lambdas that the threads are running capture the start time value by reference. The start time is set just before the gate is opened, and well after the threads have started running. The spin gate's synchronization ensures that if the state change caused by open is visible, the setting of the start time is also visible. 

 Here are one set of results from running a spingate: 

<pre class="example">
Open the gate in 1 second: 
Thread 0 waited 821ns
Thread 1 waited 14490ns
Thread 2 waited 521ns
Thread 3 waited 817ns
</pre>
</div>
</div>
</div>

<div id="outline-container-org5bc686f" class="outline-2">
<h3 id="org5bc686f">
<span class="section-number-2">2</span> Comparison with Condition Variable gate</h3>
<div class="outline-text-2" id="text-2">
 The normal way of implementing a gate like this is with a condition variable, associated mutex, and a plain bool. The mutex guarantees synchronization between the wait and open, rather than the atomic variable in the SpinGate. The unlock/lock pair in mutex have release-acquire semantics. The actual lock and unlock are done by the unique_lock guard. 

<div class="org-src-container">
<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">cvgate.h                                                           -*-C++-*-</span>
<span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> INCLUDED_CVGATE
<span class="org-preprocessor">#define</span> <span class="org-variable-name">INCLUDED_CVGATE</span>

<span class="org-preprocessor">#include</span> <span class="org-string">&lt;mutex&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;condition_variable&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;atomic&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;thread&gt;</span>

<span class="org-keyword">class</span> <span class="org-type">CVGate</span>
{
    <span class="org-constant">std</span>::<span class="org-type">mutex</span> <span class="org-variable-name">lock_</span>;
    <span class="org-constant">std</span>::<span class="org-type">condition_variable</span> <span class="org-variable-name">cv_</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">flag_</span>;

  <span class="org-keyword">public</span>:
    <span class="org-function-name">CVGate</span>();

    <span class="org-type">void</span> <span class="org-function-name">wait</span>();
    <span class="org-type">void</span> <span class="org-function-name">open</span>();
};

<span class="org-keyword">inline</span>
<span class="org-constant">CVGate</span>::<span class="org-function-name">CVGate</span>()
: lock_(),
  cv_(),
  flag_(<span class="org-constant">true</span>)
{}

<span class="org-keyword">inline</span>
<span class="org-type">void</span> <span class="org-constant">CVGate</span>::<span class="org-function-name">wait</span>() {
    <span class="org-constant">std</span>::<span class="org-type">unique_lock</span>&lt;<span class="org-constant">std</span>::<span class="org-type">mutex</span>&gt; <span class="org-function-name">lk</span>(lock_);
    cv_.wait(lk, [&amp;](){<span class="org-keyword">return</span> <span class="org-negation-char">!</span>flag_;});
}

<span class="org-keyword">inline</span>
<span class="org-type">void</span> <span class="org-constant">CVGate</span>::<span class="org-function-name">open</span>() {
    <span class="org-constant">std</span>::<span class="org-type">unique_lock</span>&lt;<span class="org-constant">std</span>::<span class="org-type">mutex</span>&gt; <span class="org-function-name">lk</span>(lock_);
    flag_ = <span class="org-constant">false</span>;
    cv_.notify_all();
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::yield();
}
<span class="org-preprocessor">#endif</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">"cvgate.h"</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Test that header is complete by including</span>
</pre>
</div>

 This has the same interface as SpinGate, and is used exactly the same way. 

 Running it shows: 

<pre class="example">
Open the gate in 1 second: 
Thread 0 waited 54845ns
Thread 1 waited 76125ns
Thread 2 waited 91977ns
Thread 3 waited 128816ns
</pre>


 That the overhead of the mutex and condition variable is significant. On the other hand, the system load while it's waiting is much lower. Spingate will use all available CPU, while CVGate yields, so useful work can be done byu the rest of the system. 

 However, for the use I was originally looking at, releasing threads for maximal overlap, spinning is clearly better. There is much less overlap as the cv blocked threads are woken up. 
</div>
</div>

<div id="outline-container-orgf2ae95b" class="outline-2">
<h3 id="orgf2ae95b">
<span class="section-number-2">3</span> Building and Running</h3>
<div class="outline-text-2" id="text-3">
 This is a minimal CMake file for building with the system compiler. 

<div class="org-src-container">
<pre class="src src-cmake"><span class="org-function-name">cmake_minimum_required</span>(VERSION 3.5)
<span class="org-function-name">set</span>(CMAKE_LEGACY_CYGWIN_WIN32 0)

<span class="org-function-name">project</span>(SpinGate C CXX)

<span class="org-function-name">set</span>(THREADS_PREFER_PTHREAD_FLAG ON)
<span class="org-function-name">find_package</span>(Threads REQUIRED)

<span class="org-function-name">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS ON)

<span class="org-function-name">set</span>(CMAKE_CXX_FLAGS <span class="org-string">"${</span><span class="org-variable-name">CMAKE_CXX_FLAGS</span><span class="org-string">} -std=c++14 -ftemplate-backtrace-limit=0"</span>)
<span class="org-function-name">set</span>(CMAKE_CXX_FLAGS <span class="org-string">"${</span><span class="org-variable-name">CMAKE_CXX_FLAGS</span><span class="org-string">} -Wall -Wextra -march=native"</span>)
<span class="org-function-name">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="org-string">"-O0 -fno-inline -g3"</span>)
<span class="org-function-name">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="org-string">"-Ofast -g0 -DNDEBUG"</span>)

<span class="org-function-name">include_directories</span>(${<span class="org-variable-name">CMAKE_CURRENT_SOURCE_DIR</span>})

<span class="org-function-name">add_executable</span>(spingate main.cpp spingate.cpp)
<span class="org-function-name">add_executable</span>(cvgate cvmain.cpp cvgate.cpp)
<span class="org-function-name">target_link_libraries</span>(spingate Threads::Threads)
<span class="org-function-name">target_link_libraries</span>(cvgate Threads::Threads)
</pre>
</div>

 And here we build a release version of the test executable: 

<div class="org-src-container">
<pre class="src src-shell" id="org9a6ea8d">mkdir -p build
<span class="org-builtin">cd</span> build
cmake -DCMAKE_BUILD_TYPE=Release ../
make
</pre>
</div>

<pre class="example">
-- Configuring done
-- Generating done
-- Build files have been written to: /home/sdowney/src/spingate/build
[ 50%] Built target cvgate
[100%] Built target spingate
</pre>
</div>
</div>

<div id="outline-container-orgd97c46f" class="outline-2">
<h3 id="orgd97c46f">
<span class="section-number-2">4</span> Org-mode source and git repo</h3>
<div class="outline-text-2" id="text-4">
 Exported from an org-mode doc. All of the source is available on github at <a href="https://github.com/steve-downey/spingate">SpinGate</a> 
</div>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/157/" class="u-url">C++ code in Org-mode</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/157/" rel="bookmark">
            <time class="published dt-published" datetime="2016-10-28T18:32:00-04:00" itemprop="datePublished" title="2016-10-28 18:32">2016-10-28 18:32</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <div id="outline-container-orgheadline1" class="outline-2">
<h3 id="orgheadline1">
<span class="section-number-2">1</span> C++</h3>
<div class="outline-text-2" id="text-1">
 This is a simple example with one c++ file, all in one src code block. 

<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Hello World++! 2.9"</span>;
}
</pre>
</div>


 The src block looks like: 

<pre class="example">
    #+HEADERS: :tangle hello.c++ :exports code :eval never
    #+BEGIN_SRC C++
    // source code
    #+END_SRC
</pre>

 The HEADERS block is on a separate line because when the buffer is evaluated, code will get run, and the SRC blocks will get rewritten, as well as the RESULTS blocks. Since we want the headers to be preserved, we can't make them part of the SRC block. 

 You can also tangle a Makefile. 

<div class="org-src-container">

<pre class="src src-makefile"><span class="org-makefile-targets">clean</span>:
    <span class="org-type">-</span><span class="org-makefile-shell">rm hello</span>

<span class="org-makefile-targets">hello</span>:  hello.c++
    clang++ hello.c++ -o hello
</pre>
</div>

 With the org mode headers exporting the code, and not evaluating this block. Just like the C++ code. We'll evaluate the makefile, and run the program, a bit further down. 

<pre class="example">
    #+HEADERS: :tangle Makefile :exports code :eval never
    #+BEGIN_SRC makefile
    # Makefile
    #+END_SRC
</pre>

 Now, we tangle the code out to the files. 

<pre class="example">
    #+NAME: tangle-buffer
    #+HEADERS: :exports both :results value
    #+BEGIN_SRC emacs-lisp
    (org-babel-tangle)
    #+END_SRC
</pre>

<div class="org-src-container">

<pre class="src src-emacs-lisp" id="orgsrcblock1">(org-babel-tangle)
</pre>
</div>

 That will write out two files when the buffer is evaluated using org-babel-execute-buffer, bound to \C-c \C-v b. 

 Give this block a name, so that where the results go can be controlled. Do that by giving the RESULTS block the name of the SRC block. Org will then produce a table of the results of executing the elisp, which is the two files produced. 

 And put the results here: 

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-left">
</colgroup>
<tbody><tr>
<td class="org-left">hello.c++</td>
<td class="org-left">Makefile</td>
</tr></tbody>
</table>


 Next, we run make with the target to compile the code. You could also simply write the compiler command here. 

<pre class="example">
    #+NAME: make-clean-hello
    #+BEGIN_SRC sh :exports both :results output
    make clean
    make hello
    #+END_SRC
</pre>

<div class="org-src-container">

<pre class="src src-sh" id="orgsrcblock2">make clean
make hello
</pre>
</div>

 And make will run our compilation as spec'd in the Makefile we just tangled out. 

<pre class="example">
rm hello
clang++ hello.c++ -o hello
</pre>


 And now get the output by running the program. 

<pre class="example">
    #+NAME: run-hello
    #+BEGIN_SRC sh :exports results
    ./hello
    #+END_SRC
</pre>

 Which prints out our hello, world text. Which is has version number to convince myself it gets updated. 

<pre class="example">
Hello World++! 2.9
</pre>
</div>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2016/10/23/building-emacs-25-1-on-ubuntu-16-10/" class="u-url">Building Emacs 25.1 on Ubuntu 16.10</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2016/10/23/building-emacs-25-1-on-ubuntu-16-10/" rel="bookmark">
            <time class="published dt-published" datetime="2016-10-23T00:00:00-04:00" itemprop="datePublished" title="2016-10-23 00:00">2016-10-23 00:00</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <div id="table-of-contents">
<h3>Table of Contents</h3>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/index.php/2016/10/23/building-emacs-25-1-on-ubuntu-16-10/#orgheadline1">1. Why notes</a></li>
<li><a href="posts/index.php/2016/10/23/building-emacs-25-1-on-ubuntu-16-10/#orgheadline2">2. Getting Ready</a></li>
<li><a href="posts/index.php/2016/10/23/building-emacs-25-1-on-ubuntu-16-10/#orgheadline3">3. Configure and build with magic option</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h3 id="orgheadline1">
<span class="section-number-2">1</span> Why notes</h3>
<div class="outline-text-2" id="text-1">
 Making notes so I don't forget, although the key problem is fixed upstream. 

 Ubuntu 16.10 (Yakkety Yak) has made a critical change to the system compiler, and everything is by default built with position independent executable support (PIE), in order to get better support for address space layout randomization. Here are the security notes for <a href="https://wiki.ubuntu.com/SecurityTeam/PIE">PIE</a>. Emacs does not dump successfully with this. The compiler option -no-pie needs to be added into CLFAGS. 

 The option also means that static libraries you've built before will probably need to be rebuilt. See the link above for typical errors. 
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h3 id="orgheadline2">
<span class="section-number-2">2</span> Getting Ready</h3>
<div class="outline-text-2" id="text-2">
 First get dpkg-dev, g++, gcc, libc, make: 

<div class="org-src-container">

<pre class="src src-bash">sudo apt-get install build-essentials
</pre>
</div>

 Then get the full set of build dependencies for last emacs, emacs24: 

<div class="org-src-container">

<pre class="src src-bash">sudo apt-get build-dep emacs24
</pre>
</div>

 Decide if you want to build just this version, or track emacs. I track from git, because. So I have a directory for emacs where I have master, emacs25, and build directories. I try to avoid building in src dirs. It makes it easier to try out different options without polluting the src. 

<div class="org-src-container">

<pre class="src src-bash">mkdir -p ~/bld/emacs
<span class="org-builtin">cd</span> ~/bld/emacs
git clone git://git.savannah.gnu.org/emacs.git
<span class="org-builtin">cd</span> emacs.git
git worktree add ../emacs-25.1 emacs-25.1
<span class="org-builtin">cd</span> ..
mkdir bld-25.1
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h3 id="orgheadline3">
<span class="section-number-2">3</span> Configure and build with magic option</h3>
<div class="outline-text-2" id="text-3">
 Now configure in the build directory: 

<div class="org-src-container">

<pre class="src src-bash"><span class="org-builtin">cd</span> bld-25.1
../emacs-25.1/configure <span class="org-sh-escaped-newline">\</span>
  --prefix=~/install/emacs-25.1 <span class="org-sh-escaped-newline">\</span>
  --with-x-toolkit=gtk3 <span class="org-sh-escaped-newline">\</span>
  --with-xwidgets <span class="org-sh-escaped-newline">\</span>
  <span class="org-variable-name">CFLAGS</span>=-no-pie
</pre>
</div>

 I built with xwidget support to play with the embedded webkit widget. It's not really useable as a browser, but has uses for rendering. I also install into a local program directory, under my homedir. 

 Build and install: 

<div class="org-src-container">

<pre class="src src-bash">make
make install
</pre>
</div>

 I have a bin directory early in $PATH so that I can select versions of local software ahead of system software. 

<div class="org-src-container">

<pre class="src src-bash"><span class="org-builtin">cd</span> ~/bin
ln -s ~/install/emacs-25.1/bin/emacs
ln -s ~/install/emacs-25.1/bin/emacsclient
</pre>
</div>

 Now you should have a working emacs 25.1 available. 
</div>
</div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/index.php/2015/01/31/video-from-osr/" class="u-url">Video from OSR</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Steve Downey
                    </span></p>
            <p class="dateline">
            <a href="posts/index.php/2015/01/31/video-from-osr/" rel="bookmark">
            <time class="published dt-published" datetime="2015-01-31T21:01:45-05:00" itemprop="datePublished" title="2015-01-31 21:01">2015-01-31 21:01</time></a>
            </p>
                </div>
            </header><div class="p-summary entry-summary">
                    <p>Video from OSR for Troop 2014
<a href="http://www.sdowney.org/wordpress/wp-content/uploads/2015/02/SUNP0018.avi">SUNP0018</a>

<a href="http://www.sdowney.org/wordpress/wp-content/uploads/2015/02/SUNP0017.avi">SUNP0017</a>

<a style="line-height: 1.714285714; font-size: 1rem;" href="http://www.sdowney.org/wordpress/wp-content/uploads/2015/02/SUNP0016.avi">SUNP0016</a>

<a style="line-height: 1.714285714; font-size: 1rem;" href="http://www.sdowney.org/wordpress/wp-content/uploads/2015/02/SUNP0015.avi">SUNP0015</a>

<a style="line-height: 1.714285714; font-size: 1rem;" href="http://www.sdowney.org/wordpress/wp-content/uploads/2015/02/SUNP0014.avi">SUNP0014</a>

<a style="line-height: 1.714285714; font-size: 1rem;" href="http://www.sdowney.org/wordpress/wp-content/uploads/2015/02/SUNP0013.avi">SUNP0013</a>

<a style="line-height: 1.714285714; font-size: 1rem;" href="http://www.sdowney.org/wordpress/wp-content/uploads/2015/02/SUNP0010.avi">SUNP0010</a>

<a style="line-height: 1.714285714; font-size: 1rem;" href="http://www.sdowney.org/wordpress/wp-content/uploads/2015/02/SUNP0009.avi">SUNP0009</a>

<a style="line-height: 1.714285714; font-size: 1rem;" href="http://www.sdowney.org/wordpress/wp-content/uploads/2015/02/SUNP0008.avi">SUNP0008</a>

<a style="line-height: 1.714285714; font-size: 1rem;" href="http://www.sdowney.org/wordpress/wp-content/uploads/2015/02/SUNP0007.avi">SUNP0007</a>

<a style="line-height: 1.714285714; font-size: 1rem;" href="http://www.sdowney.org/wordpress/wp-content/uploads/2015/02/SUNP0006.avi">SUNP0006</a>

<a style="line-height: 1.714285714; font-size: 1rem;" href="http://www.sdowney.org/wordpress/wp-content/uploads/2015/02/SUNP0005.avi">SUNP0005</a>

 </p>
                </div>
            </article>
</div>
    
        <ul class="pager postindexpager clearfix">
<li class="previous"><a href="index-9.html" rel="prev">Newer posts</a></li>
            <li class="next"><a href="index-7.html" rel="next">Older posts</a></li>
        </ul>
<!--End of body content--><footer id="footer">
            Contents © 2024         <a href="mailto:sdowney@sdowney.dev">Steve Downey</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a> - 
 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
 <img alt="Creative Commons License BY-NC-SA" style="border-width:0; margin-bottom:12px;" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a>
            
            
        </footer>
</div>
</div>


        <script src="assets/js/all-nocdn.js"></script><script src="assets/js/luxon.min.js"></script><!-- fancy dates --><script>
        luxon.Settings.defaultLocale = "en";
        fancydates(2, {"preset": false, "format": "yyyy-MM-dd HH:mm"});
        </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-VGV27RDN3E"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VGV27RDN3E');
</script>
</body>
</html>
