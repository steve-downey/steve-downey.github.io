<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Stuff, and more stuff">
<meta name="viewport" content="width=device-width">
<title>What Comes to Mind</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer">
<link rel="stylesheet" href="assets/css/rst.min.css">
<link rel="stylesheet" href="assets/css/foundation.min.css">
<link rel="stylesheet" href="assets/css/app.css">
<link rel="stylesheet" href="assets/css/modus-vivendi-tinted.css">
<link href="assets/css/custom.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="alternate" type="application/atom+xml" title="Atom" href="feed.atom">
<link rel="canonical" href="https://sdowney.org/">
<link rel="next" href="index-9.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="posts/substitution-is-sometimes-a-failure/" type="text/html">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
</head>
<body>

    

    
<div class="top-bar">
<div class="top-bar-left">
<ul class="menu">
<li class="menu-text"><a href="https://sdowney.org/" title="What Comes to Mind" rel="home">What Comes to Mind</a></li>
                <li><a href="archive.html">Archives</a></li>
                <li><a href="categories/index.html">Tags</a></li>
                <li><a href="mailto:sdowney@sdowney.dev"><i class="fa fa-envelope"></i></a></li>
                <li><a href="https://github.com/steve-downey">GitHub <i class="fa-brands fa-square-github"></i></a></li>
                <li><a href="https://mastodon.social/@Sdowney">Mastodon <i class="fa-brands fa-mastodon"></i></a></li>
                <li><a href="https://bsky.app/profile/sdowney.bsky.social">Bluesky <i class="fa-brands fa-square-bluesky"></i></a></li>
                <li><a href="feed.atom">ATOM <i class="fa-solid fa-atom"></i></a></li>
                <li><a href="rss.xml">RSS <i class="fa-solid fa-rss"></i></a></li>
    
    
    </ul>
</div>
</div>

    

<div class="callout large primary">
<div class="row column text-center">

<h1>What Comes to Mind</h1>
<h2 class="subheader">Stuff, and more stuff</h2>

</div>
</div>

<div class="row medium-8 large-7 columns">


    <div class="blog-post">
    <h3>
<a href="posts/substitution-is-sometimes-a-failure/">Substitution is Sometimes a Failure</a><br><small>2025-11-28 12:06</small>
</h3>
    <div>

        <div class="abstract" id="org2939d20">
<p>
Why are optional::transform and optional::and_then not constrained by <code>invocable</code>?
</p>

</div>
<div id="outline-container-org452148a" class="outline-2">
<h2 id="org452148a">
<span class="section-number-2">1.</span> Optional "Monadic" Interface</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="http://wg21.link/P0798">Monadic operations for std::optional</a>
</p>
<ul class="org-ul">
<li>
<code>transform</code> is the c++ spelling for <code>map</code> or <code>fmap</code>
</li>
<li>
<code>and_then</code> is monadic <code>bind</code> for optional</li>
<li>
<code>or_else</code> is dual to <code>and_then</code>
</li>
</ul>
<p>
<code>or_else</code> also has:
</p>

<blockquote>
<p>
Constraints: <code>F</code> models <code>invocable</code> and <code>T</code> models <code>{move,copy}_constructible</code>.
</p>
</blockquote>

<p>
<code>transform</code> and <code>and_then</code> do not.
</p>

<p>
They don't work if you don't give them invocables, and rely on <code>invoke_result_t</code> to compute the result. So why not constrain them?
</p>
</div>
</div>
<div id="outline-container-org95813d0" class="outline-2">
<h2 id="org95813d0">
<span class="section-number-2">2.</span> SFINAE is shallow</h2>
<div class="outline-text-2" id="text-2">
<p>
The problem is if another template has to be instantiated in order to evaluate the template of interest, and that template has an error, you get an error, not a substitution failure. And, it turns out, lambdas are a common source of the problem and a common case in real use.
</p>

<p>
Consider the code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">void</span> <span class="org-function-name">f</span>(<span class="org-type">int</span>&amp;);

<span class="org-keyword">auto</span> <span class="org-variable-name">l</span> = [](<span class="org-keyword">auto</span>&amp; <span class="org-variable-name">y</span>) {
    f(y);
    <span class="org-keyword">return</span> 42;
};
</pre>
</div>

<p>
The two important parts are the <code>auto&amp;</code> parameter and the implicit deduced return type.
</p>

<p>
We can rewrite it, to make things possibly more obvious:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">struct</span> <span class="org-type">Func</span> {
    <span class="org-keyword">template</span> &lt;<span class="org-keyword">typename</span> <span class="org-type">T</span>&gt;
    <span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">()</span>(<span class="org-type">T</span>&amp; <span class="org-variable-name">t</span>) {
        f(t);
        <span class="org-keyword">return</span> 42;
    }
};
</pre>
</div>

<p>
and to slightly spoil things, the problem code is effectively:
</p>
<div class="org-src-container">
<pre class="src src-c++">static_assert(<span class="org-constant">std</span>::<span class="org-type">invocable</span>&lt;Func, <span class="org-type">int</span> <span class="org-keyword">const</span>&amp;&gt;);
</pre>
</div>

<p>
which produces:
</p>
<div class="org-src-container">
<pre class="src src-c++">&lt;source&gt;: In instantiation of <span class="org-warning">'</span><span class="org-keyword">auto</span> <span class="org-constant">Func</span>::<span class="org-keyword">operator</span>()(<span class="org-type">T</span>&amp;) [with T = <span class="org-keyword">const</span> <span class="org-type">int</span>]<span class="org-warning">'</span>:
type_traits:2565:26:   required by substitution of <span class="org-warning">'</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">class</span> <span class="org-type">_Fn</span>, <span class="org-keyword">class</span> ... <span class="org-type">_Args</span>&gt; <span class="org-keyword">static</span> <span class="org-constant">std</span>::<span class="org-type">__result_of_success</span>&lt;<span class="org-keyword">decltype</span> (declval&lt;<span class="org-type">_Fn</span>&gt;()((<span class="org-type">declval</span>&lt;<span class="org-type">_Args</span>&gt;)()...)), <span class="org-constant">std</span>::__invoke_other&gt; <span class="org-constant">std</span>::<span class="org-constant">__result_of_other_impl</span>::_S_test(<span class="org-type">int</span>) [with _Fn = Func; _Args = {<span class="org-keyword">const</span> <span class="org-type">int</span>&amp;}]<span class="org-warning">'</span>
type_traits:2576:55:   required from <span class="org-warning">'</span><span class="org-keyword">struct</span> <span class="org-constant">std</span>::<span class="org-type">__result_of_impl</span>&lt;<span class="org-constant">false</span>, <span class="org-constant">false</span>, Func, <span class="org-keyword">const</span> <span class="org-type">int</span>&amp;&gt;<span class="org-warning">'</span>
type_traits:3038:12:   recursively required by substitution of <span class="org-warning">'</span><span class="org-keyword">template</span>&lt;<span class="org-keyword">class</span> <span class="org-type">_Result</span>, <span class="org-keyword">class</span> <span class="org-type">_Ret</span>&gt; <span class="org-keyword">struct</span> <span class="org-constant">std</span>::<span class="org-type">__is_invocable_impl</span>&lt;<span class="org-type">_Result</span>, <span class="org-type">_Ret</span>, <span class="org-constant">true</span>, <span class="org-constant">std</span>::<span class="org-type">__void_t</span>&lt;<span class="org-keyword">typename</span> <span class="org-constant">_CTp</span>::<span class="org-type">type</span>&gt; &gt; [<span class="org-constant">with</span> _Result = <span class="org-constant">std</span>::<span class="org-type">__invoke_result</span>&lt;Func, <span class="org-keyword">const</span> <span class="org-type">int</span>&amp;&gt;; _Ret = <span class="org-type">void</span>]<span class="org-warning">'</span>
type_traits:3038:12:   required from <span class="org-warning">'</span><span class="org-keyword">struct</span> <span class="org-constant">std</span>::<span class="org-type">is_invocable</span>&lt;Func, <span class="org-keyword">const</span> <span class="org-type">int</span>&amp;&gt;<span class="org-warning">'</span>
type_traits:3286:71:   required from <span class="org-warning">'</span><span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">bool</span> <span class="org-constant">std</span>::<span class="org-type">is_invocable_v</span>&lt;Func, <span class="org-keyword">const</span> <span class="org-type">int</span>&amp;&gt;<span class="org-warning">'</span>
concepts:336:25:   required from <span class="org-type">here</span>
&lt;source&gt;:12:10: error: binding reference of type <span class="org-warning">'</span><span class="org-type">int</span>&amp;<span class="org-warning">'</span> to <span class="org-warning">'</span><span class="org-keyword">const</span> <span class="org-type">int</span><span class="org-warning">'</span> discards qualifiers
   12 |         f(t);
      |         ~^~~
&lt;source&gt;:2:12: note:   initializing argument 1 of <span class="org-warning">'</span><span class="org-type">void</span> f(<span class="org-type">int</span>&amp;)<span class="org-warning">'</span>
    2 |     <span class="org-type">void</span> f(<span class="org-type">int</span>&amp;);
      |            ^~~~
Compiler returned: 1
</pre>
</div>
<p>
<a href="https://compiler-explorer.com/z/W1jT6bxrf">Compiler Explorer</a>
</p>

<p>
as the compiler is unhappy about trying to call the function <code>f</code> with a <code>const int&amp;</code>.
</p>

<p>
If the lambda or <code>Func</code> is changed to have a non-deduced return type, the instantiation errors from the check to <code>invocable</code> go away, although you still get an error calling either with a <code>const int</code>.
</p>

<p>
So why do we run into this with <code>transform</code> if we were to constrain it with <code>invocable</code> ?
</p>

<p>
The compiler needs to figure out the overload set in order to resolve which one to use from the set. There are four of them two for the l- and r- value category and two for the const overloads.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">class</span> <span class="org-type">F</span>&gt; <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">transform</span>(<span class="org-type">F</span>&amp;&amp; <span class="org-variable-name">f</span>) &amp;;
<span class="org-keyword">template</span>&lt;<span class="org-keyword">class</span> <span class="org-type">F</span>&gt; <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">transform</span>(<span class="org-type">F</span>&amp;&amp; <span class="org-variable-name">f</span>) <span class="org-keyword">const</span> &amp;;
<span class="org-keyword">template</span>&lt;<span class="org-keyword">class</span> <span class="org-type">F</span>&gt; <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">transform</span>(<span class="org-type">F</span>&amp;&amp; <span class="org-variable-name">f</span>) &amp;&amp;;
<span class="org-keyword">template</span>&lt;<span class="org-keyword">class</span> <span class="org-type">F</span>&gt; <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">transform</span>(<span class="org-type">F</span>&amp;&amp; <span class="org-variable-name">f</span>) <span class="org-keyword">const</span> &amp;&amp;;
</pre>
</div>
<p>
with differing computations of the resulting <code>optional</code> being returned.
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">using</span> <span class="org-type">U</span> = <span class="org-type">invoke_result_t</span>&lt;F, <span class="org-keyword">decltype</span>(<span class="org-constant">std</span>​::​move(*val))&gt;;
<span class="org-comment-delimiter">//</span><span class="org-comment">or
</span><span class="org-keyword">using</span> <span class="org-type">U</span> = <span class="org-type">remove_cv_t</span>&lt;<span class="org-type">invoke_result_t</span>&lt;F, <span class="org-keyword">decltype</span>(*val)&gt;&gt;;
</pre>
</div>

<p>
So, in order to work out what the templated <code>transform</code>'s signature really is, it has to compute what the invocable returns, and since the invocable has deduced return type, it needs to instantiate it, and instantiating with <code>const int</code> causes an error.
</p>

<p>
This is unfortunate.
</p>

<p>
If we constrain <code>transform</code> we get the same errors as above. <a href="https://compiler-explorer.com/z/r1qbjx4zG">See here,</a> with just enough of an <code>optional</code> to compile.
</p>
</div>
</div>
<div id="outline-container-org7a1b9db" class="outline-2">
<h2 id="org7a1b9db">
<span class="section-number-2">3.</span> Constraints, what are they good for</h2>
<div class="outline-text-2" id="text-3">
<p>
Not absolutely nothing.
</p>

<p>
Constraints in the library:
</p>

<blockquote>
<p>
Constraints: the conditions for the function's participation in overload resolution ([over.match]).
</p>

<p>
[Note 1: Failure to meet such a condition results in the function's silent non-viability. — end note]
</p>

<p>
[Example 1: An implementation can express such a condition via a constraint-expression ([temp.constr.decl]). — end example]
</p>
</blockquote>

<p>
<a href="https://eel.is/c++draft/description#structure.specifications-3.1">[structure.specifications] 3.1</a>
</p>

<p>
Constraints are for making an overload not exist if the constraint isn't met. It's not a way of signaling an error. Those are <code>Mandates</code>:
</p>

<blockquote>
<p>
Mandates: the conditions that, if not met, render the program ill-formed.
</p>

<p>
[Example 2: An implementation can express such a condition via the constant-expression in a static_assert-declaration ([dcl.pre]). If the diagnostic is to be emitted only after the function has been selected by overload resolution, an implementation can express such a condition via a constraint-expression ([temp.constr.decl]) and also define the function as deleted. — end example]
</p>
</blockquote>

<p>
<a href="https://eel.is/c++draft/description#structure.specifications-3.2">[structure.specifications] 3.2</a>
</p>

<p>
Asking to run <code>and_then</code> on a non-invocable probably ought not to say there is no such function, but instead tell you it can't be invoked. I'm now not convinced that <code>or_else</code> should be constrained this way. It's not significantly better for <code>o.or_else(5)</code> to fail to resolve, mentioning <code>invocable</code>, than produce an error that <code>invoke_result_t</code> doesn't work, or that <code>f</code> can't be invoked. The kind of error is a minor detail.
</p>

<p>
Constraints that let you control the choice of alternatives are wonderful, and requires clauses are normal programmer accessible, unlike SFINAE, or even <code>enable_if</code>. But without an overload set to constrain, there possibly should not be a constraint.
</p>
</div>
</div>
<div id="outline-container-orgd1b0868" class="outline-2">
<h2 id="orgd1b0868">
<span class="section-number-2">4.</span> Can we do better?</h2>
<div class="outline-text-2" id="text-4">
<p>
There are some notes in <a href="https://wg21.link/P0798">P0798</a> that suggest that Deducing This might help, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html">P0847</a>.
</p>

<p>
The idea would to be to NOT have all the value category overloads that need to be checked, but to just have a single one that deduces what <code>this</code> is and provide it as a template parameter for further use. The contained parameter could be forwarded using <code>forward_like&lt;Self&gt;</code>.
</p>

<p>
P0847 has discussion about how deducing this might be applied to optional. There's also discussion of deducing this and the SFINAE-unfriendly auto at <a href="https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/">C++23’s Deducing this: what it is, why it is, how to use it</a>.
</p>

<p>
With the tools we have today, it looks possible, but still slightly messy. I managed to get my implementation of optional to compile and pass its own tests with.
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">F</span>, <span class="org-keyword">class</span> <span class="org-type">Self</span>&gt;
    <span class="org-keyword">requires</span>(
        <span class="org-constant">std</span>::<span class="org-type">invocable</span>&lt;<span class="org-type">F</span>,
                       <span class="org-keyword">decltype</span>(<span class="org-constant">std</span>::forward_like&lt;<span class="org-type">Self</span>&gt;(<span class="org-constant">std</span>::declval&lt;T&gt;()))&gt;)
<span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">transform</span>(<span class="org-keyword">this</span> Self&amp;&amp; self, <span class="org-type">F</span>&amp;&amp; <span class="org-variable-name">f</span>)
    -&gt; <span class="org-type">optional</span>&lt;<span class="org-constant">std</span>::<span class="org-type">invoke_result_t</span>&lt;
        <span class="org-type">F</span>,
        <span class="org-keyword">decltype</span>(<span class="org-constant">std</span>::forward_like&lt;<span class="org-type">Self</span>&gt;(<span class="org-constant">std</span>::declval&lt;T&gt;()))&gt;&gt; {
    <span class="org-keyword">using</span> <span class="org-type">U</span> = <span class="org-constant">std</span>::<span class="org-type">invoke_result_t</span>&lt;<span class="org-type">F</span>,
                                   <span class="org-keyword">decltype</span>(<span class="org-constant">std</span>::forward_like&lt;<span class="org-type">Self</span>&gt;(
                                       <span class="org-constant">std</span>::declval&lt;T&gt;()))&gt;;
    static_assert(<span class="org-negation-char">!</span><span class="org-constant">std</span>::<span class="org-type">is_array_v</span>&lt;<span class="org-type">U</span>&gt;);
    static_assert(<span class="org-negation-char">!</span><span class="org-constant">std</span>::<span class="org-type">is_same_v</span>&lt;<span class="org-type">U</span>, <span class="org-type">in_place_t</span>&gt;);
    static_assert(<span class="org-negation-char">!</span><span class="org-constant">std</span>::<span class="org-type">is_same_v</span>&lt;<span class="org-type">U</span>, <span class="org-type">nullopt_t</span>&gt;);
    static_assert(<span class="org-constant">std</span>::<span class="org-type">is_object_v</span>&lt;<span class="org-type">U</span>&gt; || <span class="org-constant">std</span>::<span class="org-type">is_reference_v</span>&lt;<span class="org-type">U</span>&gt;);
    <span class="org-keyword">if</span> (self.has_value()) {
        <span class="org-keyword">return</span> <span class="org-type">optional</span>&lt;<span class="org-type">U</span>&gt;{<span class="org-constant">detail</span>::from_function,
                           <span class="org-constant">std</span>::forward&lt;<span class="org-type">F</span>&gt;(f),
                           <span class="org-constant">std</span>::forward_like&lt;<span class="org-type">Self</span>&gt;(self.value_)};
    }
    <span class="org-keyword">return</span> <span class="org-type">optional</span>&lt;<span class="org-type">U</span>&gt;;
}
</pre>
</div>

<p>
If there were a <code>std::forward_like_t</code>, it might be possible to reduce some of the noise in computing the value category used for the <code>T</code>. I also have not thought extensively about if the requires clause is truly needed in light of the <code>invoke_result_</code> that can now be used in the trailing return type.
</p>
</div>
</div>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/entry-fountain-pens/">Entry Fountain Pens</a><br><small>2025-01-19 11:07</small>
</h3>
    <div>

        <div>
<div class="abstract" id="orgd12e55b">
<p>
A list of very good inexpensive fountain pens.
</p>

</div>

<p class="more"><a href="posts/entry-fountain-pens/">Read more…</a></p>
</div>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/nikola-blog-infrastructure/">Nikola Blog Infrastructure</a><br><small>2024-12-23 13:15</small>
</h3>
    <div>

        <div>
<div class="abstract" id="org334ae85">
<p>
I've migrated from WordPress to a static blog generator–Nikola. This is how it works.
</p>

</div>

<p class="more"><a href="posts/nikola-blog-infrastructure/">Read more…</a></p>
</div>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2024/05/19/concept-maps-using-c23-library-tech/">Concept Maps using C++23 Library Tech</a><br><small>2024-05-19 11:51</small>
</h3>
    <div>

        <div id="outline-container-orga2bfebe" class="outline-2">
<h3 id="orga2bfebe">Abstract</h3>
<div class="outline-text-2" id="text-orga2bfebe">
<p> C++0x Concepts had a feature <code>Concept Maps</code> that allowed a set of functions, types, and template definitions to be associated with a concept and the map to be specialized for types that meet the concept. </p>

<p> This allowed open extension of a concept. </p>

<p class="more"><a href="posts/index.php/2024/05/19/concept-maps-using-c23-library-tech/">Read more…</a></p>
</div>
</div>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2024/05/18/slides-from-cnow-2023-async-control-flow/">Slides from C++Now 2023 Async Control Flow</a><br><small>2024-05-18 18:27</small>
</h3>
    <div>

        <div>
<div id="outline-container-org8b3a3c0" class="outline-2">
<h3 id="org8b3a3c0">Using Sender/Receiver for Async Control Flow</h3>
<div class="outline-text-2" id="text-org8b3a3c0">
<p> Steve Downey </p>

<p> These are the slides, slightly rerendered, from my presentation at C++Now 2023. </p>
</div>
</div>
<div id="outline-container-orga88bc52" class="outline-2">
<h3 id="orga88bc52">Abstract</h3>
<div class="outline-text-2" id="text-orga88bc52">
<p> How can P2300 Senders be composed using sender adapters and sender factories to provide arbitrary program control flow? </p>

<ul class="org-ul">
<li>How do I use these things?</li>
</ul>
<ul class="org-ul">
<li>Where can I steal from?</li>
</ul>
<p class="more"><a href="posts/index.php/2024/05/18/slides-from-cnow-2023-async-control-flow/">Read more…</a></p>
</div>
</div>
</div>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2023/12/24/some-informal-remarks-towards-a-new-theory-of-trait-customization/">Some Informal Remarks Towards a New Theory of Trait Customization</a><br><small>2023-12-24 00:00</small>
</h3>
    <div>

        <div>
<div id="outline-container-org0a7dcc5" class="outline-2">
<h3 id="org0a7dcc5">A Possible Technique</h3>
<div class="outline-text-2" id="text-org0a7dcc5">
<div class="org-src-container">
<label class="org-src-name"><em></em></label>
<pre class="src src-c++" id="nil"><span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-function-name">g</span>(<span class="org-type">int</span> <span class="org-variable-name">lhs</span>, <span class="org-type">int</span> <span class="org-variable-name">rhs</span>) {
    <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">op</span> = <span class="org-type">partial_eq</span>&lt;<span class="org-type">int</span>&gt;;
    <span class="org-keyword">return</span> op.ne(lhs, rhs);
}
</pre>
</div>
<a href="https://godbolt.org/z/Ge43cWfn8">Compiler Explorer with Supporting Code</a>

A trait is defined as a template variable that implements the required operations. Implementation of those operations is possible via a variety of techniques, but existence is concept checkable. It might prove useful to explicitly opt in to a sufficiently generic trait.

The technique satisfies the openness requirement, that the trait can be created independently of the type that models the trait. There can still only be one definition, but this enables opting std:: types into new traits, for example.

It also doesn't universally grab an operation name. The trait variable is namespaceable.

Syntax isn't really awesome, but not utterly unworkable.

</div>
</div>

<p class="more"><a href="posts/index.php/2023/12/24/some-informal-remarks-towards-a-new-theory-of-trait-customization/">Read more…</a></p>
</div>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/special-blocks-and-emacs-org-mode-export/">Special Blocks and Emacs Org-mode Export</a><br><small>2021-12-03 00:00</small>
</h3>
    <div>

        <div>
<nav id="table-of-contents" role="doc-toc"><h3>Table of Contents</h3>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="posts/special-blocks-and-emacs-org-mode-export/#orgf2bc23f">1. Delete blocks and text</a></li>
<li><a href="posts/special-blocks-and-emacs-org-mode-export/#org76721e5">2. Insert blocks and text</a></li>
<li><a href="posts/special-blocks-and-emacs-org-mode-export/#org3c7f3fc">3. Comparison Table</a></li>
</ul>
</div>
</nav><ul class="org-ul">
<li>Document number:</li>
<li>Date:  2021-12-03</li>
<li>Author: Steve Downey &lt;sdowney2@bloomberg.net&gt;, &lt;sdowney@gmail.com&gt;</li>
<li>Audience: WG21 Emacs Authors</li>
</ul>
<div class="ABSTRACT" id="org257c800">
<p> Abstract: Making emacs org-mode more usable for writing WG21 papers. </p>

</div>

<p class="more"><a href="posts/special-blocks-and-emacs-org-mode-export/">Read more…</a></p>
</div>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2021/10/03/a-local-cmake-workflow-with-docker/">A local CMake workflow with Docker</a><br><small>2021-10-03 00:00</small>
</h3>
    <div>

        <div>
<p> l#+BLOG: sdowney </p>

<p> An outline of a template that provides an automated workflow driving a CMake project in a docker container. </p>

<p> This post must be read in concert with <a href="https://github.com/steve-downey/scratch">https://github.com/steve-downey/scratch</a> of which it is part. </p>

<div id="outline-container-orge73d9dc" class="outline-2">
<h3 id="orge73d9dc">Routine process should be automated</h3>
<div class="outline-text-2" id="text-orge73d9dc">
<p> Building a project that uses cmake runs through a predictable lifecycle that you should be able to pick up where you left off without remembering, and for which you should be able to state your goal, not the step you are on. <code>make</code> is designed for this, and can drive the processs. </p>
</div>

<p class="more"><a href="posts/index.php/2021/10/03/a-local-cmake-workflow-with-docker/">Read more…</a></p>
</div>
</div>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2021/10/03/stdexecution-sender-receiver-and-the-continuation-monad/">std::execution, Sender/Receiver, and the Continuation Monad</a><br><small>2021-10-03 00:00</small>
</h3>
    <div>

        <div>
<p> Some thoughts on the <a href="https://wg21.link/p2300">std::execution</a> proposal and my understanding of the underlying theory. </p>

<div id="outline-container-org6280fb4" class="outline-2">
<h3 id="org6280fb4">What's proposed</h3>
<div class="outline-text-2" id="text-org6280fb4">
<p> From the paper's <a href="https://brycelelbach.github.io/wg21_p2300_std_execution/std_execution.html#intro">Introduction</a> </p>

<blockquote>
<p> This paper proposes a self-contained design for a Standard C++ framework for managing asynchronous execution on generic execution contexts. It is based on the ideas in [P0443R14] and its companion papers. </p>
</blockquote>

<p> Which doesn't tell you much. </p>

<p> It proposes a framework where the principle abstractions are Senders, Receivers, and Schedulers. </p>

<dl class="org-dl">
<dt>Sender</dt>
<dd>A composable unit of work.</dd>
<dt>Receiver</dt>
<dd>Delimits work, handling completion, exceptions, or cancellation.</dd>
<dt>Schedulers</dt>
<dd>Arranges for the context work is done in.</dd>
</dl>
<p class="more"><a href="posts/index.php/2021/10/03/stdexecution-sender-receiver-and-the-continuation-monad/">Read more…</a></p>
</div>
</div>
</div>
    </div>

    </div>
    <div class="blog-post">
    <h3>
<a href="posts/index.php/2021/01/16/standard-vocabulary-for-algorithms/">Standard Vocabulary for Algorithms</a><br><small>2021-01-16 18:22</small>
</h3>
    <div>

        <div>
<p>This is feedback after considering <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2214r0.html">A Plan for C++23 Ranges</a>

Disclosure: I voted in favor of this. It does <b>not</b> suggest work on <a href="https://wg21.link/P1255">views::maybe [P1255R6]​</a>. I'm fine with that priority.
</p>
<div id="outline-container-orga27da53" class="outline-2">
<h3 id="orga27da53">Vocabulary is not just Types between Components</h3>
<div class="outline-text-2" id="text-orga27da53">

 There's broad agreement that 'vocabulary types' belong in the standard. Domain independent types that can be used between otherwise uncoupled facilities. They each depend on facilities provided by Standard C++ and can thus be developed independently. Each component can rely on the API of a core vocabulary type not changing. This allows facilities to communicate effectively.

A component can have std::string or std::vector&lt;int&gt; in its interface with little concern. The STL parts of the standard library have always relied on concepts for constraining template parameters implicitly, requiring an Iterator of particular category in places, or specializing algorithms based on such. Composition of container types has also been natural. No one is confused by a std::unordered_map&lt;std::string, std::vector&lt;my::person&gt;&gt;.

<p class="more"><a href="posts/index.php/2021/01/16/standard-vocabulary-for-algorithms/">Read more…</a></p>
</div>
</div>
</div>
    </div>

    </div>


        <div class="column row">
            <ul class="pagination" role="navigation" aria-label="Pagination">
<li>
                    <a href="index-9.html" rel="next">» <span class="show-for-sr">Older posts</span></a>
                </li>
            </ul>
</div>


    



        
        <script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script><script>
                renderMathInElement(document.body,
                    {
                        
delimiters: [
    {left: "$$", right: "$$", display: true},
    {left: "\\[", right: "\\]", display: true},
    {left: "\\begin{equation*}", right: "\\end{equation*}", display: true},
    {left: "$", right: "$", display: false},
    {left: "\\(", right: "\\)", display: false}
]

                    }
                );
            </script><hr>
<footer id="footer"><p><small>Contents © 2025         <a href="mailto:sdowney@sdowney.dev">Steve Downey</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a> - 
 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
 <img alt="Creative Commons License BY-NC-SA" style="border-width:0; margin-bottom:12px;" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a></small></p>
            
        </footer>
</div>

    



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VGV27RDN3E"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VGV27RDN3E');
</script>
</body>
</html>
